<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 12 Feb 2026 17:48:35 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/" rel="self" type="application/rss+xml"/><item><title>ctfshow代码审计</title><link>https://baozongwi.xyz/p/ctfshow-code-audit/</link><guid>https://baozongwi.xyz/p/ctfshow-code-audit/</guid><pubDate>Tue, 08 Oct 2024 14:06:33 +0000</pubDate><description>最最最基础的php待审</description><content:encoded>web301 进来之后就看到一个函数sds_decode，但是在这个文件里面都没找到利用这个函数的地方，然后发现sql注入直接写入木马
1 2 POST: userid=a&amp;amp;amp;#39;union select &amp;amp;amp;#39;&amp;amp;amp;lt;?php eval(\$_POST[a]);?&amp;amp;amp;gt;&amp;amp;amp;#39;into …</content:encoded></item><item><title>shuangyuCTF2024</title><link>https://baozongwi.xyz/p/shuangyuctf2024/</link><guid>https://baozongwi.xyz/p/shuangyuctf2024/</guid><pubDate>Sun, 06 Oct 2024 20:29:53 +0000</pubDate><description>垃圾题</description><content:encoded>0x01 这次打的不舒服，总感觉奇奇怪怪
0x02 question web签到 查看源码可得
shuangyuCTF-web1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 …</content:encoded></item><item><title>MoeCTF2024</title><link>https://baozongwi.xyz/p/moectf2024/</link><guid>https://baozongwi.xyz/p/moectf2024/</guid><pubDate>Sat, 05 Oct 2024 18:46:20 +0000</pubDate><description>0x01 前言 赶紧来看看
0x02 question ez_http 抓不到包，直接看吧
1 2 3 4 5 6 7 8 http://127.0.0.1:57206/?xt=大帅b POST ； imoau=sb Referer:https://www.xidian.edu.cn/ X-Forwarded-For:127.0.0.1 Cookie:user=admin User-Agent:MoeDedicatedBrowser Web渗透测试与审计入门指北 直接搭建网站即可
弗拉格之地的入口 访问/robots.txt
垫刀之路01: MoeCTF？启动！ env即可
Moectf 2024 Web 调查问卷 填写问卷就可以了
ProveYourLove 表白三百次
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import requests import time # 定义目标URL url = &amp;amp;#34;http://127.0.0.1:51843/questionnaire&amp;amp;#34; # 定义请求头 headers = { &amp;amp;#34;Content-Length&amp;amp;#34;: &amp;amp;#34;129&amp;amp;#34;, &amp;amp;#34;sec-ch-ua-platform&amp;amp;#34;: &amp;amp;#34;Windows&amp;amp;#34;, &amp;amp;#34;User-Agent&amp;amp;#34;: &amp;amp;#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36&amp;amp;#34;, &amp;amp;#34;sec-ch-ua&amp;amp;#34;: &amp;amp;#39;&amp;amp;#34;Google Chrome&amp;amp;#34;;v=&amp;amp;#34;129&amp;amp;#34;, &amp;amp;#34;Not=A?Brand&amp;amp;#34;;v=&amp;amp;#34;8&amp;amp;#34;, &amp;amp;#34;Chromium&amp;amp;#34;;v=&amp;amp;#34;129&amp;amp;#34;&amp;amp;#39;, &amp;amp;#34;Content-Type&amp;amp;#34;: &amp;amp;#34;application/json&amp;amp;#34;, &amp;amp;#34;sec-ch-ua-mobile&amp;amp;#34;: &amp;amp;#34;?0&amp;amp;#34;, &amp;amp;#34;Accept&amp;amp;#34;: &amp;amp;#34;*/*&amp;amp;#34;, &amp;amp;#34;Origin&amp;amp;#34;: &amp;amp;#34;http://127.0.0.1:51843&amp;amp;#34;, &amp;amp;#34;Sec-Fetch-Site&amp;amp;#34;: &amp;amp;#34;same-origin&amp;amp;#34;, &amp;amp;#34;Sec-Fetch-Mode&amp;amp;#34;: &amp;amp;#34;cors&amp;amp;#34;, &amp;amp;#34;Sec-Fetch-Dest&amp;amp;#34;: &amp;amp;#34;empty&amp;amp;#34;, &amp;amp;#34;Referer&amp;amp;#34;: &amp;amp;#34;http://127.0.0.1:51843/&amp;amp;#34;, &amp;amp;#34;Accept-Encoding&amp;amp;#34;: &amp;amp;#34;gzip, deflate&amp;amp;#34;, &amp;amp;#34;Accept-Language&amp;amp;#34;: &amp;amp;#34;zh-CN,zh;q=0.9,en;q=0.8&amp;amp;#34;, &amp;amp;#34;Connection&amp;amp;#34;: &amp;amp;#34;close&amp;amp;#34; } # 定义请求体 data = { &amp;amp;#34;nickname&amp;amp;#34;: &amp;amp;#34;baozongwi&amp;amp;#34;, &amp;amp;#34;user_gender&amp;amp;#34;: &amp;amp;#34;male&amp;amp;#34;, &amp;amp;#34;target&amp;amp;#34;: &amp;amp;#34;admin&amp;amp;#34;, &amp;amp;#34;target_gender&amp;amp;#34;: &amp;amp;#34;female&amp;amp;#34;, &amp;amp;#34;message&amp;amp;#34;: &amp;amp;#34;我爱你&amp;amp;#34;, &amp;amp;#34;anonymous&amp;amp;#34;: &amp;amp;#34;false&amp;amp;#34; } # 发送POST请求 for i in range(310): response = requests.post(url, headers=headers, json=data) time.sleep(0.1) # 打印响应状态码和内容 print(f&amp;amp;#34;Status Code: {response.status_code}&amp;amp;#34;) print(f&amp;amp;#34;Response Content: {response.text}&amp;amp;#34;) 弗拉格之地的挑战 1 2 3 &amp;amp;lt;!--恭喜你找到了网页的源代码，通常在这里题目会放一些提示，做题没头绪一定要先进来看一下--&amp;amp;gt; &amp;amp;lt;!--flag1: bW9lY3Rm--&amp;amp;gt; &amp;amp;lt;!--下一步：/flag2hh.php--&amp;amp;gt; 抓包发现第二个界面</description><content:encoded>0x01 前言 赶紧来看看
0x02 question ez_http 抓不到包，直接看吧
1 2 3 4 5 6 7 8 http://127.0.0.1:57206/?xt=大帅b POST ； imoau=sb Referer:https://www.xidian.edu.cn/ …</content:encoded></item><item><title>flask原型链污染</title><link>https://baozongwi.xyz/p/flask-prototype-pollution/</link><guid>https://baozongwi.xyz/p/flask-prototype-pollution/</guid><pubDate>Thu, 03 Oct 2024 16:57:12 +0000</pubDate><description>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的所有属性和方法，还可以添加新的属性和方法，或者重写父类的方法。
同时还有几个重要方法，这里直接引用一位师傅所写的
在Python中，定义类是通过class关键字，class后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的，所有类的本源都是object类 可以自由地给一个实例变量绑定属性，像js 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把类内置的属性绑上 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到 判断一个变量是否是某个类型可以用isinstance()判断。 普通继承 在子类中，你可以使用 super() 函数来调用父类的方法。这在子类需要扩展而不是完全重写父类方法时特别有用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Animal: def __init__(self, name): self.name = name def speak(self): raise NotImplementedError(&amp;amp;#34;Subclass must implement this abstract method&amp;amp;#34;) def eat(self): print(f&amp;amp;#34;{self.name} is eating.&amp;amp;#34;) class Dog(Animal): def __init__(self, name, breed): super().__init__(name) # 调用父类的构造函数 self.breed = breed def speak(self): print(f&amp;amp;#34;{self.name} says Woof!&amp;amp;#34;) def fetch(self): print(f&amp;amp;#34;{self.name} is fetching the ball.&amp;amp;#34;) class Cat(Animal): def __init__(self, name, color): super().__init__(name) # 调用父类的构造函数 self.color = color def speak(self): super().speak() # 调用父类的 speak 方法 print(f&amp;amp;#34;{self.name} says Meow!&amp;amp;#34;) def scratch(self): print(f&amp;amp;#34;{self.name} is scratching the furniture.&amp;amp;#34;) instance = Cat(&amp;amp;#34;无情&amp;amp;#34;,&amp;amp;#34;black&amp;amp;#34;) print(instance.name) 看看就行感觉没啥好讲的，看就能看懂</description><content:encoded>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的 …</content:encoded></item><item><title>SCTF2024</title><link>https://baozongwi.xyz/p/sctf2024/</link><guid>https://baozongwi.xyz/p/sctf2024/</guid><pubDate>Wed, 02 Oct 2024 11:17:26 +0000</pubDate><description>0x01 前言 又是变成劳大的一个周末
0x02 question ezrender 这里进入之后是一个登录框，本来是黑盒的，但是后面给了代码和提示
1 ulimit -n =2048 先把代码放出来吧
app.py
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 from flask import Flask, render_template, request, render_template_string,redirect from verify import * from User import User import base64 from waf import waf app = Flask(__name__,static_folder=&amp;amp;#34;static&amp;amp;#34;,template_folder=&amp;amp;#34;templates&amp;amp;#34;) user={} @app.route(&amp;amp;#39;/register&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;,&amp;amp;#34;GET&amp;amp;#34;]) def register(): method=request.method if method==&amp;amp;#34;GET&amp;amp;#34;: return render_template(&amp;amp;#34;register.html&amp;amp;#34;) if method==&amp;amp;#34;POST&amp;amp;#34;: data = request.get_json() name = data[&amp;amp;#34;username&amp;amp;#34;] pwd = data[&amp;amp;#34;password&amp;amp;#34;] if name != None and pwd != None: if data[&amp;amp;#34;username&amp;amp;#34;] in user: return &amp;amp;#34;This name had been registered&amp;amp;#34; else: user[name] = User(name, pwd) return &amp;amp;#34;OK&amp;amp;#34; @app.route(&amp;amp;#39;/login&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;,&amp;amp;#34;GET&amp;amp;#34;]) def login(): method=request.method if method==&amp;amp;#34;GET&amp;amp;#34;: return render_template(&amp;amp;#34;login.html&amp;amp;#34;) if method==&amp;amp;#34;POST&amp;amp;#34;: data = request.get_json() name = data[&amp;amp;#34;username&amp;amp;#34;] pwd = data[&amp;amp;#34;password&amp;amp;#34;] if name != None and pwd != None: if name not in user: return &amp;amp;#34;This account is not exist&amp;amp;#34; else: if user[name].pwd == pwd: token=generateToken(user[name]) return &amp;amp;#34;OK&amp;amp;#34;,200,{&amp;amp;#34;Set-Cookie&amp;amp;#34;:&amp;amp;#34;Token=&amp;amp;#34;+token} else: return &amp;amp;#34;Wrong password&amp;amp;#34; @app.route(&amp;amp;#39;/admin&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;,&amp;amp;#34;GET&amp;amp;#34;]) def admin(): try: token = request.headers.get(&amp;amp;#34;Cookie&amp;amp;#34;)[6:] except: return &amp;amp;#34;Please login first&amp;amp;#34; else: infor = json.loads(base64.b64decode(token)) name = infor[&amp;amp;#34;name&amp;amp;#34;] token = infor[&amp;amp;#34;secret&amp;amp;#34;] result = check(user[name], token) method=request.method if method==&amp;amp;#34;GET&amp;amp;#34;: return render_template(&amp;amp;#34;admin.html&amp;amp;#34;,name=name) if method==&amp;amp;#34;POST&amp;amp;#34;: template = request.form.get(&amp;amp;#34;code&amp;amp;#34;) if result != &amp;amp;#34;True&amp;amp;#34;: return result, 401 #just only blackList if waf(template): return &amp;amp;#34;Hacker Found&amp;amp;#34; result=render_template_string(template) print(result) if result !=None: return &amp;amp;#34;OK&amp;amp;#34; else: return &amp;amp;#34;error&amp;amp;#34; @app.route(&amp;amp;#39;/&amp;amp;#39;, methods=[&amp;amp;#34;GET&amp;amp;#34;]) def index(): return redirect(&amp;amp;#34;login&amp;amp;#34;) @app.route(&amp;amp;#39;/removeUser&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;]) def remove(): try: token = request.headers.get(&amp;amp;#34;Cookie&amp;amp;#34;)[6:] except: return &amp;amp;#34;Please login first&amp;amp;#34; else: infor = json.loads(base64.b64decode(token)) name = infor[&amp;amp;#34;name&amp;amp;#34;] token = infor[&amp;amp;#34;secret&amp;amp;#34;] result = check(user[name], token) if result != &amp;amp;#34;True&amp;amp;#34;: return result, 401 rmuser=request.form.get(&amp;amp;#34;username&amp;amp;#34;) user.pop(rmuser) return &amp;amp;#34;Successfully Removed:&amp;amp;#34;+rmuser if __name__ == &amp;amp;#39;__main__&amp;amp;#39;: # for the safe del __builtins__.__dict__[&amp;amp;#39;eval&amp;amp;#39;] app.run(debug=False, host=&amp;amp;#39;0.0.0.0&amp;amp;#39;, port=8080) User.py</description><content:encoded>0x01 前言 又是变成劳大的一个周末
0x02 question ezrender 这里进入之后是一个登录框，本来是黑盒的，但是后面给了代码和提示
1 ulimit -n =2048 先把代码放出来吧
app.py
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 …</content:encoded></item><item><title>session文件包含</title><link>https://baozongwi.xyz/p/session-file-inclusion/</link><guid>https://baozongwi.xyz/p/session-file-inclusion/</guid><pubDate>Fri, 27 Sep 2024 13:39:03 +0000</pubDate><description>经典</description><content:encoded>0x01 前言 之前觉得很难的姿势，现在学习了一下，感觉还行啊，果然多多尝试才有结果
0x02 question 这个的大部分基础知识都在session反序列化提到了，所以这里就将session文件包含所需要的，当涉及session的时候，我们可以利用ID来保留属于自己的信息
那么我们如果上传文件进 …</content:encoded></item><item><title>深入浅出XSS</title><link>https://baozongwi.xyz/p/xss-in-depth/</link><guid>https://baozongwi.xyz/p/xss-in-depth/</guid><pubDate>Wed, 25 Sep 2024 08:04:23 +0000</pubDate><description>0x01 前言 最近发现xss的利用还是挺多的，但是自己又处于一个只会用低级payload的水平,所以来学习一下
0x02 question what‘s this 原理 原理就是很简单，类似于注入，我们插入了恶意代码在网页中，并且也被成功解析了
利用场景 浏览器可以执行JavaScript代码（这不是废话吗）。 网页可以显示用户输入的内容。包括但不限于：根据url中的参数渲染网页、预览输入框写好的内容、留言板等其他用户提交的内容等。 那么很显然这是被动的攻击，在之前并不流行，但是现在互联网主要讲求一个&amp;amp;quot;互&amp;amp;quot;,所以自然而然的也可以进行利用了，而能来干什么(最常见的钓鱼)
干啥 窃取cookie或token来获得用户登录态； 劫持流量，把用户正在访问的页面跳转到钓鱼网站； 盗用账户来转账、群发信息等； 利用用户的设备来发起DDOS攻击； demo 这次我们从一个最简单的demo来看看原理
1 2 3 &amp;amp;lt;?php $xss=$_GET[&amp;amp;#39;id&amp;amp;#39;]; echo $xss; 1 ?id=&amp;amp;lt;script&amp;amp;gt;alert(1)&amp;amp;lt;/script&amp;amp;gt; 直接就出现弹窗了，也就是因为我们的恶意代码被解析插入，这样子看其实还是不是很能理解，再来个demo，这个demo也就花了我两个小时吧，艹想哭了
为了更加直观的看到为什么会造成xss，我零基础学了如果使用Tomcat来搭建一个本地服务，其中载入jsp漏洞代码，即可进行xss测试
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &amp;amp;lt;%@ page language=&amp;amp;#34;java&amp;amp;#34; contentType=&amp;amp;#34;text/html; charset=UTF-8&amp;amp;#34; pageEncoding=&amp;amp;#34;UTF-8&amp;amp;#34;%&amp;amp;gt; &amp;amp;lt;!DOCTYPE html&amp;amp;gt; &amp;amp;lt;html lang=&amp;amp;#34;zh-CN&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;head&amp;amp;gt; &amp;amp;lt;meta charset=&amp;amp;#34;UTF-8&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;meta name=&amp;amp;#34;viewport&amp;amp;#34; content=&amp;amp;#34;width=device-width, initial-scale=1.0&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title&amp;amp;gt;XSS 测试页面&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;/head&amp;amp;gt; &amp;amp;lt;body&amp;amp;gt; &amp;amp;lt;h1&amp;amp;gt;XSS 测试页面&amp;amp;lt;/h1&amp;amp;gt; &amp;amp;lt;form action=&amp;amp;#34;xss_test.jsp&amp;amp;#34; method=&amp;amp;#34;get&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;label for=&amp;amp;#34;message&amp;amp;#34;&amp;amp;gt;输入消息:&amp;amp;lt;/label&amp;amp;gt; &amp;amp;lt;input type=&amp;amp;#34;text&amp;amp;#34; id=&amp;amp;#34;message&amp;amp;#34; name=&amp;amp;#34;message&amp;amp;#34; value=&amp;amp;#34;&amp;amp;lt;%= request.getParameter(&amp;amp;#34;message&amp;amp;#34;) == null ? &amp;amp;#34;&amp;amp;#34; : request.getParameter(&amp;amp;#34;message&amp;amp;#34;) %&amp;amp;gt;&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;button type=&amp;amp;#34;submit&amp;amp;#34;&amp;amp;gt;提交&amp;amp;lt;/button&amp;amp;gt; &amp;amp;lt;/form&amp;amp;gt; &amp;amp;lt;div&amp;amp;gt; 您输入的消息是：&amp;amp;lt;%= request.getParameter(&amp;amp;#34;message&amp;amp;#34;) == null ? &amp;amp;#34;null&amp;amp;#34; : request.getParameter(&amp;amp;#34;message&amp;amp;#34;) %&amp;amp;gt; &amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;/body&amp;amp;gt; &amp;amp;lt;/html&amp;amp;gt; 先简单的写个xss_test.jsp直接用来测试的</description><content:encoded>0x01 前言 最近发现xss的利用还是挺多的，但是自己又处于一个只会用低级payload的水平,所以来学习一下
0x02 question what‘s this 原理 原理就是很简单，类似于注入，我们插入了恶意代码在网页中，并且也被成功解析了
利用场景 浏览器可以执行JavaScript代码（这 …</content:encoded></item><item><title>ctfshow终极考核</title><link>https://baozongwi.xyz/p/ctfshow-final-assessment/</link><guid>https://baozongwi.xyz/p/ctfshow-final-assessment/</guid><pubDate>Tue, 24 Sep 2024 12:16:07 +0000</pubDate><description>考核我的内网渗透？</description><content:encoded>web640 进入就有flag
web644 查看源码发现一个页面，但是这样子又跳转回去了，扫一下吧那
1 2 3 4 5 [00:21:46] 200 - 43B - /.bowerrc [00:21:47] 200 - 34B - /.gitignore [00:21:49] 200 - 2KB …</content:encoded></item></channel></rss>