<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 19 Feb 2026 21:44:48 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/" rel="self" type="application/rss+xml"/><item><title>陇剑杯决赛2025</title><link>https://baozongwi.xyz/p/longjian-cup-finals-2025/</link><guid>https://baozongwi.xyz/p/longjian-cup-finals-2025/</guid><pubDate>Fri, 19 Sep 2025 22:53:10 +0800</pubDate><description>ezzupload 查看文件，拿到源码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 &amp;amp;lt;?php session_start(); $session_id = session_id(); $target_dir = &amp;amp;#34;/var/www/html/uploads/$session_id/&amp;amp;#34;; if (!is_dir($target_dir)) { mkdir($target_dir, 0755, true); chown($target_dir, &amp;amp;#39;www-data&amp;amp;#39;); chgrp($target_dir, &amp;amp;#39;www-data&amp;amp;#39;); } ?&amp;amp;gt; &amp;amp;lt;form enctype=&amp;amp;#39;multipart/form-data&amp;amp;#39; action=&amp;amp;#39;&amp;amp;#39; method=&amp;amp;#39;post&amp;amp;#39;&amp;amp;gt; &amp;amp;lt;input type=&amp;amp;#39;file&amp;amp;#39; name=&amp;amp;#39;fileToUpload&amp;amp;#39;&amp;amp;gt; &amp;amp;lt;input type=&amp;amp;#34;submit&amp;amp;#34; value=&amp;amp;#34;Upload&amp;amp;#34; name=&amp;amp;#34;submit&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;/form&amp;amp;gt; &amp;amp;lt;?php if (isset($_FILES[&amp;amp;#39;fileToUpload&amp;amp;#39;])) { $target_file = basename($_FILES[&amp;amp;#34;fileToUpload&amp;amp;#34;][&amp;amp;#34;name&amp;amp;#34;]); $session_id = session_id(); $target_dir = &amp;amp;#34;/var/www/html/uploads/$session_id/&amp;amp;#34;; $target_file_path = $target_dir . $target_file; $uploadOk = 1; $lastDotPosition = strrpos($target_file, &amp;amp;#39;.&amp;amp;#39;); if (file_exists($target_file_path)) { echo &amp;amp;#34;Sorry, file already exists.\n&amp;amp;#34;; $uploadOk = 0; } if ($_FILES[&amp;amp;#34;fileToUpload&amp;amp;#34;][&amp;amp;#34;size&amp;amp;#34;] &amp;amp;gt; 50000) { echo &amp;amp;#34;Sorry, your file is too large.\n&amp;amp;#34;; $uploadOk = 0; } if ($lastDotPosition == false) { $filename = $target_file; $extension = &amp;amp;#39;&amp;amp;#39;; } else { $filename = substr($target_file, 0, $lastDotPosition); $extension = substr($target_file, $lastDotPosition + 1); } if ($extension !== &amp;amp;#39;&amp;amp;#39; &amp;amp;amp;&amp;amp;amp; $extension !== &amp;amp;#39;txt&amp;amp;#39;) { echo &amp;amp;#34;Sorry, only .txt extensions are allowed.\n&amp;amp;#34;; $uploadOk = 0; } if (!(preg_match(&amp;amp;#39;/^[a-f0-9]{32}$/&amp;amp;#39;, $session_id))) { echo &amp;amp;#34;Sorry, that is not a valid session ID.\n&amp;amp;#34;; $uploadOk = 0; } if ($uploadOk == 0) { echo &amp;amp;#34;Sorry, your file was not uploaded.\n&amp;amp;#34;; } else { $temp_file_path = $target_dir . uniqid(&amp;amp;#39;temp_&amp;amp;#39;, true) . &amp;amp;#39;.tmp&amp;amp;#39;; if (move_uploaded_file($_FILES[&amp;amp;#34;fileToUpload&amp;amp;#34;][&amp;amp;#34;tmp_name&amp;amp;#34;], $temp_file_path)) { chmod($temp_file_path, 0000); $is_hidden = (substr($target_file, 0, 1) === &amp;amp;#39;.&amp;amp;#39;); if ($is_hidden) { chmod($temp_file_path, 0644); } if (rename($temp_file_path, $target_file_path)) { echo &amp;amp;#34;The file &amp;amp;#34; . htmlspecialchars(basename($_FILES[&amp;amp;#34;fileToUpload&amp;amp;#34;][&amp;amp;#34;name&amp;amp;#34;])) . &amp;amp;#34; has been uploaded.&amp;amp;#34;; if (!$is_hidden) { chmod($target_file_path, 0000); } } else { echo &amp;amp;#34;Sorry, there was an error renaming your file.&amp;amp;#34;; if (file_exists($temp_file_path)) { unlink($temp_file_path); } } } else { echo &amp;amp;#34;Sorry, there was an error uploading your file.&amp;amp;#34;; } $old_path = getcwd(); chdir($target_dir); shell_exec(&amp;amp;#39;chmod 000 *&amp;amp;#39;); chdir($old_path); } } ?&amp;amp;gt; 是一个文件上传，有临时目录的限制，不能够进行条件竞争，但是最后的shell_exec(&amp;#39;chmod 000 *&amp;#39;);，其中的*，不会匹配到隐藏文件，可以尝试上传文件</description><content:encoded>ezzupload 查看文件，拿到源码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 …</content:encoded></item><item><title>我相比去年之二十岁</title><link>https://baozongwi.xyz/p/from-19-to-now/</link><guid>https://baozongwi.xyz/p/from-19-to-now/</guid><pubDate>Sun, 14 Sep 2025 15:15:03 +0800</pubDate><description>大学之后过的第一个生日</description><content:encoded>没想到吧，我居然也活到20岁了，而且比起去年其实还挺有进步的，有些熟人可能会说，啊，你不是7.23嘛，为什么是今天算生日呢，因为四川人过农历~
为什么说是大学之后过的第一个生日？因为我几乎是一点都不记得我前三年的生日怎么过的了，也可能就是浑浑噩噩的睡了一天，或者是鼓捣自己的东西，比如说，去年打了三十 …</content:encoded></item><item><title>Jdk7u21反序列化漏洞</title><link>https://baozongwi.xyz/p/jdk7u21-deserialization/</link><guid>https://baozongwi.xyz/p/jdk7u21-deserialization/</guid><pubDate>Thu, 11 Sep 2025 14:50:59 +0800</pubDate><description>前面学习了CC链之后，我们发现其实无论他多么复杂，也就是个readObject到trasform的过程，转换成一个大思想，其实就是触发动态执行的地方，到Sink点的地方。
CommonsCollections系列反序列化的核心点是那一堆 Transformer ，特别是其中的 InvokerTransformer 、 InstantiateTransformer CommonsBeanutils反序列化的核心点是PropertyUtils#getProperty，因为这个方法会触发任意对象的getter 在jdk8u71之前，我们有sun.reflect.annotation.AnnotationInvocationHandler，学习CC1的时候利用这个类 时Map#put、 Map#get，现在来看到equalsImpl方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private Boolean equalsImpl(Object var1) { if (var1 == this) { return true; } else if (!this.type.isInstance(var1)) { return false; } else { for(Method var5 : this.getMemberMethods()) { String var6 = var5.getName(); Object var7 = this.memberValues.get(var6); Object var8 = null; AnnotationInvocationHandler var9 = this.asOneOfUs(var1); if (var9 != null) { var8 = var9.memberValues.get(var6); } else { try { var8 = var5.invoke(var1); } catch (InvocationTargetException var11) { return false; } catch (IllegalAccessException var12) { throw new AssertionError(var12); } } if (!memberValueEquals(var7, var8)) { return false; } } return true; } } 首先可以看到很明显的反射调用var8 = var5.invoke(var1);，也就是说他在遍历所有this.type的方法，如果我们可控type为Templates类，则势必会调用到其中的newTransformer()或getOutputProperties()方法，从而RCE。</description><content:encoded>前面学习了CC链之后，我们发现其实无论他多么复杂，也就是个readObject到trasform的过程，转换成一个大思想，其实就是触发动态执行的地方，到Sink点的地方。
CommonsCollections系列反序列化的核心点是那一堆 Transformer ， …</content:encoded></item><item><title>陇剑杯2025以及湾区杯2025</title><link>https://baozongwi.xyz/p/longjian-and-bay-area-cup-2025/</link><guid>https://baozongwi.xyz/p/longjian-and-bay-area-cup-2025/</guid><pubDate>Mon, 08 Sep 2025 20:01:26 +0800</pubDate><description>今年学生组已经成为了上分最激烈的组（对不起兄弟，太几把搞笑了）</description><content:encoded>只简单说说，因为题目都不是很难
LJB forge Unicode字符注册，登录可以上传PKL文件，把example下载下来得知结构，写opcode写到example里面就可以解决不出网的问题
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 …</content:encoded></item><item><title>Shiro550反序列化</title><link>https://baozongwi.xyz/p/shiro550-deserialization/</link><guid>https://baozongwi.xyz/p/shiro550-deserialization/</guid><pubDate>Sat, 06 Sep 2025 17:07:54 +0800</pubDate><description>shiro550中CC6&amp;amp;&amp;amp;CB1&amp;amp;&amp;amp;无CC依赖的CB1</description><content:encoded>shiro550 前面学习加载字节码之后学习了几条CC链，发现通过TemplatesImpl构造的利用链，理论上可以执行任意Java代码，这是一种非常通用的手法，不受到对于链的限制，特别是构造内存吗，执行任意Java代码的需求就更加浓烈了。那这个手法有多潮呢？我们就以之前拿shell拿到爽现在也能捡 …</content:encoded></item><item><title>Ctfshow中Web应用安全与防护</title><link>https://baozongwi.xyz/p/ctfshow-web-security-defense/</link><guid>https://baozongwi.xyz/p/ctfshow-web-security-defense/</guid><pubDate>Wed, 03 Sep 2025 22:35:59 +0800</pubDate><description>六六六，个个都是极客少年</description><content:encoded>说在前面 “啊？还是难了吗，这个是面向高三学生的”
Base64编码隐藏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;amp;amp;lt;script&amp;amp;amp;gt; …</content:encoded></item><item><title>Java中一些有意思的CC链</title><link>https://baozongwi.xyz/p/interesting-cc-chains-in-java/</link><guid>https://baozongwi.xyz/p/interesting-cc-chains-in-java/</guid><pubDate>Tue, 02 Sep 2025 21:33:45 +0800</pubDate><description>CC6&amp;amp;&amp;amp;CC3&amp;amp;&amp;amp;CC2&amp;amp;&amp;amp;CC4</description><content:encoded>本文会记录一些有意思的、必要学习的CC利用链，不过可能需要几天完工，慢慢学稳稳学
CC6 P牛版本 前面说到CC1受到jdk版本限制的原因，其实就是因为 sun.reflect.annotation.AnnotationInvocationHandler#readObject的逻辑变化了。 也就是说 …</content:encoded></item><item><title>Java中动态加载字节码</title><link>https://baozongwi.xyz/p/java-dynamic-bytecode-loading/</link><guid>https://baozongwi.xyz/p/java-dynamic-bytecode-loading/</guid><pubDate>Tue, 02 Sep 2025 21:21:47 +0800</pubDate><description>本文介绍几个加载字节码的常用方法。方便后续学习CC2、fastjson、内存马等应用做
概念 严格意义上来说，Java字节码(ByteCode)其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储 在.class文件中。
知周所众，不同平台、不同CPU的计算机指令有差异，但因为Java是一门跨平台的编译型语言，所以这些差异对于上层开发者来说是透明的，上层开发者只需要将自己的代码编译一次，即可运行在不同平台的JVM虚拟机中。
甚至，开发者可以用类似Scala、Kotlin这样的语言编写代码，只要你的编译器能够将代码编译成.class文 件，都可以在JVM虚拟机中运行（超模的JVM）:
加载也分几种，不过不论是加载远程class文件，还是本地的class或jar文件，Java都经历的是下面这三个方法调用:
loadClass的作用是从已加载的类缓存、父加载器等位置寻找类(这里实际上是双亲委派机制)，在前面没有找到的情况下，执行findClass findClass的作用是根据基础URL指定的方式来加载类的字节码，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给defineClass defineClass的作用是处理前面传入的字节码，将其处理成真正的Java类 利用URLClassLoader加载远程class文件 Java的ClassLoader来用来加载字节码文件最基础的方法，学习反射的时候就有所了解，
ClassLoader是什么呢?它就是一个“加载器”，告诉Java虚拟机如何加载这个类。
Java默认的ClassLoader就是根据类名来加载类，这个类名是类完整路径，如java.lang.Runtime。
URLClassLoader实际上是我们平时默认使用的AppClassLoader的父类，所以解释URLClassLoader的工作过程实际上就是在解释默认的Java类加载器的工作流程。
正常情况下，Java会根据配置项sun.boot.class.path和java.class.path中列举到的基础路径(这些路径经过处理后为java.net.URL类)来查找和加载.class文件来加载，而这个基础路径有分为三种情况:
URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找 .class 文件。 URL以斜杠 / 结尾，且协议名是 file，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找 .class 文件。 URL以斜杠 / 结尾，且协议名不是 file，则使用最基础的 Loader 来寻找类。 一般地，我们远程加载肯定是用第三种，类似于RMI服务，测试一下
1 2 3 4 5 6 7 8 package Base.Unserialize.Base; public class Hello { static { System.out.println(&amp;amp;#34;Hello guys!&amp;amp;#34;); } } 放在本地8888端口，再写一个加载的类
1 2 3 4 5 6 7 8 9 10 11 12 13 package Base.Unserialize.Base; import java.net.URL; import java.net.URLClassLoader; public class HelloClassLoader { public static void main( String[] args ) throws Exception { URL[] urls = {new URL(&amp;amp;#34;http://localhost:8888/&amp;amp;#34;)}; URLClassLoader loader = URLClassLoader.newInstance(urls); Class c = loader.loadClass(&amp;amp;#34;Hello&amp;amp;#34;); c.newInstance(); } }</description><content:encoded>本文介绍几个加载字节码的常用方法。方便后续学习CC2、fastjson、内存马等应用做
概念 严格意义上来说，Java字节码(ByteCode)其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储 在.class文件中。
知周所众，不同平台、不同CPU的计算机指令有差异，但因为Java是一门跨 …</content:encoded></item></channel></rss>