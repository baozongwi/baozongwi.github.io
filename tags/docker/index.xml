<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/tags/docker/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 12 Feb 2026 20:58:38 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/tags/docker/" rel="self" type="application/rss+xml"/><item><title>不出网compose编写</title><link>https://baozongwi.xyz/p/docker-compose-no-egress/</link><guid>https://baozongwi.xyz/p/docker-compose-no-egress/</guid><pubDate>Wed, 24 Sep 2025 01:02:13 +0800</pubDate><description>之前年初SUCTF的时候，毕师傅因为余神写的Docker不够权威，导致了DNS出网，直接可以把flag给leak出来，后来我也没解决DNS出网的问题，直到有一次让infer出题的时候他知道怎么弄
一般我是直接把DNS设置为空，但是这样子还是能出网，而要不出网的话，需要设置为127.0.0.1
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 services: test: image: test:latest build: context: . dockerfile: Dockerfile ports: - &amp;amp;#34;8000:8000&amp;amp;#34; restart: unless-stopped deploy: resources: limits: memory: 512M cpus: &amp;amp;#39;0.5&amp;amp;#39; environment: - PYTHONUNBUFFERED=1 tmpfs: - /tmp:size=100M,noexec,nosuid,nodev dns: - 127.0.0.1 cap_drop: - ALL cap_add: - SETUID - SETGID - CHOWN networks: - private networks: private: driver: bridge driver_opts: com.docker.network.bridge.enable_ip_masquerade: &amp;amp;#39;false&amp;amp;#39; 只要用这个compose启动的容器，那确实是不出网的，但是我给image导出为tar再导入使用的时候发现tar导入的镜像直接启动的容器依旧是出网的，使用命令为</description><content:encoded>之前年初SUCTF的时候，毕师傅因为余神写的Docker不够权威，导致了DNS出网，直接可以把flag给leak出来，后来我也没解决DNS出网的问题，直到有一次让infer出题的时候他知道怎么弄
一般我是直接把DNS设置为空，但是这样子还是能出网，而要不出网的话，需要设置为127.0.0.1
1 2 …</content:encoded></item><item><title>Docker Remote Api 未授权利用</title><link>https://baozongwi.xyz/p/docker-remote-api-unauthorized-access-exploit/</link><guid>https://baozongwi.xyz/p/docker-remote-api-unauthorized-access-exploit/</guid><pubDate>Mon, 22 Sep 2025 20:20:51 +0800</pubDate><description>概念 一位大佬使用docker swarm管理docker集群的时候，发现了管理的docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page not found，然后他研究了下，发现这是 Docker Remote API，可以执行docker命令，比如访问 http://host:2375/containers/json 会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，其他操作比如创建/删除container，拉取image等操作也都可以通过API调用完成。（不是哥们）
Docker Remote API 是 Docker 提供的 RESTful 接口 ，默认绑定 2375（非加密）和 2376（TLS 加密）端口，用于远程管理 Docker 容器、镜像、网络等资源。 当管理员错误配置 允许未授权访问 （如直接暴露 0.0.0.0:2375），攻击者可通过该 API 完全控制 Docker 环境 ，进而实现 容器逃逸 ，最终接管宿主机。
对于docker中的通信流程，有以下几个重要组件
组件 作用 Docker Client 用户使用的命令行工具（如 **docker ps**），通过 API 与 Daemon 交互。 Docker Daemon 后台服务（**dockerd**），实际管理容器、镜像、存储等资源。 Docker Remote API 提供 REST 接口（默认 **2375** 端口），接收 Client 或 HTTP 请求。</description><content:encoded>概念 一位大佬使用docker swarm管理docker集群的时候，发现了管理的docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page not found，然后他研究了下，发现这是 Docker Remote API，可以执行docker命 …</content:encoded></item><item><title>CTFd搭建</title><link>https://baozongwi.xyz/p/ctfd-setup/</link><guid>https://baozongwi.xyz/p/ctfd-setup/</guid><pubDate>Mon, 17 Mar 2025 15:47:27 +0000</pubDate><description>刷</description><content:encoded>你问我为什么又要搭建CTFd了，因为我打了两个月的国际赛了发现外面还是用的CTFd，当然你如果要使用动态靶机的话，要使用赵总的插件，那样子CTFd根本承受不住，所以如果使用的是静态靶机，比如校赛的话，就用CTFd比较简单方便
docker安装&amp;amp;amp;amp;&amp;amp;amp;amp;换源 之前的文章，基础使用docker …</content:encoded></item><item><title>CDUCTF2024</title><link>https://baozongwi.xyz/p/cductf2024/</link><guid>https://baozongwi.xyz/p/cductf2024/</guid><pubDate>Sun, 03 Nov 2024 12:16:18 +0000</pubDate><description>0x01 这里我只放Dockerfile和start.sh怎么写的，以及wp
0x02 question ez_pop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 &amp;amp;lt;?php show_source(__FILE__); error_reporting(0); class C{ private $name; private $age; public function __construct($name,$age) { $this-&amp;amp;gt;age=$age; $this-&amp;amp;gt;name=$name; } public function __destruct() { echo $this-&amp;amp;gt;name-&amp;amp;gt;me; } } class D{ public $source; public $str; public function __toString() { eval($this-&amp;amp;gt;str-&amp;amp;gt;source); } public function __wakeup() { $this-&amp;amp;gt;str=&amp;amp;#34;baozongwi&amp;amp;#34;; } } class U{ public $cmd; public function __invoke() { echo $this-&amp;amp;gt;cmd; } } class sec{ public $p; public function __get($p) { $function=$this-&amp;amp;gt;p; return $function(); } } if(isset($_GET[&amp;amp;#39;a&amp;amp;#39;])){ $b=unserialize($_GET[&amp;amp;#39;a&amp;amp;#39;]); } 首先进入环境我们看到是一个php反序列化</description><content:encoded>0x01 这里我只放Dockerfile和start.sh怎么写的，以及wp
0x02 question ez_pop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 …</content:encoded></item><item><title>docker学习以及基础web题目部署</title><link>https://baozongwi.xyz/p/docker-learning-and-basic-web-deployment/</link><guid>https://baozongwi.xyz/p/docker-learning-and-basic-web-deployment/</guid><pubDate>Thu, 15 Aug 2024 21:23:03 +0000</pubDate><description>0x01 前言 docker必须要会啊，虽然折磨了我好久好久
这里使用的是抽奖得到的DK盾Ubuntu22
0x02 action 安装 1 2 3 4 5 6 7 8 sudo apt update sudo apt install apt-transport-https curl curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg echo &amp;amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release &amp;amp;amp;&amp;amp;amp; echo &amp;amp;#34;$VERSION_CODENAME&amp;amp;#34;) stable&amp;amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list &amp;amp;gt; /dev/null sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动＋拉取最简单的镜像 1 2 systemctl start docker systemctl status docker 配置 换源即可
1 2 3 4 5 6 7 8 9 10 11 12 sudo rm /etc/docker/daemon.json sudo vim /etc/docker/daemon.json { &amp;amp;#34;registry-mirrors&amp;amp;#34;: [ &amp;amp;#34;https://docker.1ms.run&amp;amp;#34; ] } sudo systemctl daemon-reload sudo systemctl restart docker 随便搞个镜像看看行不行，这里是一个php的RCE题目，代码在</description><content:encoded>0x01 前言 docker必须要会啊，虽然折磨了我好久好久
这里使用的是抽奖得到的DK盾Ubuntu22
0x02 action 安装 1 2 3 4 5 6 7 8 sudo apt update sudo apt install apt-transport-https curl curl …</content:encoded></item></channel></rss>