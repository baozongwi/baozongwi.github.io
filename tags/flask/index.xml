<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/tags/flask/</link><description>baozongwi's blog</description><lastBuildDate>Thu, 12 Feb 2026 21:00:03 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/tags/flask/" rel="self" type="application/rss+xml"/><item><title>ACTF2025(webAK)</title><link>https://baozongwi.xyz/p/actf2025-web-ak/</link><guid>https://baozongwi.xyz/p/actf2025-web-ak/</guid><pubDate>Sat, 26 Apr 2025 10:15:22 +0000</pubDate><description>AK也没进入前十</description><content:encoded>ACTF upload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 …</content:encoded></item><item><title>ctfshow单身杯二</title><link>https://baozongwi.xyz/p/ctfshow-singles-cup-2/</link><guid>https://baozongwi.xyz/p/ctfshow-singles-cup-2/</guid><pubDate>Sun, 26 Jan 2025 22:03:33 +0000</pubDate><description>刷</description><content:encoded>签到·好玩的PHP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 &amp;amp;amp;lt;?php error_reporting(0); highlight_file(__FILE__); …</content:encoded></item><item><title>ctfshow西瓜杯</title><link>https://baozongwi.xyz/p/ctfshow-watermelon-cup/</link><guid>https://baozongwi.xyz/p/ctfshow-watermelon-cup/</guid><pubDate>Fri, 24 Jan 2025 20:35:08 +0000</pubDate><description>gxn出的题太好了</description><content:encoded>CodeInject 1 2 3 4 5 6 &amp;amp;amp;lt;?php error_reporting(0); show_source(__FILE__); eval(&amp;amp;amp;#34;var_dump((Object)$_POST[1]);&amp;amp;amp;#34;); 直接拼接就可以了
1 1=system(&amp;amp;amp;#34;tac …</content:encoded></item><item><title>SUCTF2025</title><link>https://baozongwi.xyz/p/suctf2025/</link><guid>https://baozongwi.xyz/p/suctf2025/</guid><pubDate>Mon, 13 Jan 2025 16:41:17 +0000</pubDate><description>出了一道中等难度的题目最后二十多解</description><content:encoded>0x01 说在前面 这次是联合战队SU主办，我也当了两天的播报员，同时作为哥哥们与参赛师傅进行答疑的桥梁，说实话不敢想，甚至还出了一道非常简单的题目，之前根本不敢想这种
0x02 question SU_blog 预期 首先进来是一个普通的博客网站，非常之简陋，而这里注册一个账号，进入网站之后发现页 …</content:encoded></item><item><title>铁三2024</title><link>https://baozongwi.xyz/p/iron-three-2024/</link><guid>https://baozongwi.xyz/p/iron-three-2024/</guid><pubDate>Sun, 15 Dec 2024 21:24:24 +0000</pubDate><description>怎么什么都是我一个人在干</description><content:encoded>0x01 前言 规则真他妈多
0x02 question zeroshell_1 进来之后看到流量包，然后看到唯一一个有参数的流量，跟踪http流量
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &amp;amp;amp;lt;html&amp;amp;amp;gt; …</content:encoded></item><item><title>蜀道山2024</title><link>https://baozongwi.xyz/p/shudaoshan-2024/</link><guid>https://baozongwi.xyz/p/shudaoshan-2024/</guid><pubDate>Mon, 18 Nov 2024 20:17:47 +0000</pubDate><description>第一次出题</description><content:encoded>0x01 前言 收到联办消息是暑假的时候，也是我第一次被外面所认可？谢谢P爹给我机会
0x02 question 海关警察训练平台 这是一个海关警察训练平台，你的任务是判断所给图片能否进入境内，但是全部判断正确的成功页面好像丢失了？？flag在内网 …</content:encoded></item><item><title>DSBCTF2024</title><link>https://baozongwi.xyz/p/dsbctf2024/</link><guid>https://baozongwi.xyz/p/dsbctf2024/</guid><pubDate>Wed, 13 Nov 2024 11:11:11 +0000</pubDate><description>0x01 这次很荣幸投稿了一题，大菜鸡师傅也收了，但是测题的时候，可能是我的污染功底不够扎实吧，有个非预期，这里给大家写一份详细的wp
0x02 ez_inject 预期 首先进入之后先注册，然后看到下面这几个页面
这样子一看肯定就是注册页面有污染了，但是在哪里呢，F12看看有啥东西
发现除了有个cookie没了
1 eyJlY2hvX21lc3NhZ2UiOiJmc2Rmc2QiLCJpc19hZG1pbiI6MCwidXNlcm5hbWUiOiJiYW96b25nd2kifQ.ZzQM2g.UMnGpHtoMS9hsHEgg3M6epEcnoM 这个格式一看两个点，不排除是jwt的可能当然session的可能性更大，那么都试试
就说明不是jwt了，那么用flask-unsign解密一下
1 flask-unsign --decode --cookie &amp;amp;#39;eyJlY2hvX21lc3NhZ2UiOiJmc2Rmc2QiLCJpc19hZG1pbiI6MCwidXNlcm5hbWUiOiJiYW96b25nd2kifQ.ZzQM2g.UMnGpHtoMS9hsHEgg3M6epEcnoM&amp;amp;#39; 发现确实是这里，但是不知道key的话怎么办呢，这里是session那么大概率是flask，也就是普通的merge函数进行污染，我们本地写个demo
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from flask import * import os app = Flask(__name__) app.config[&amp;amp;#39;SECRET_KEY&amp;amp;#39;] = &amp;amp;#39;baozongwi&amp;amp;#39; class test: def __init__(self): pass def merge(src, dst): for k, v in src.items(): if hasattr(dst, &amp;amp;#39;__getitem__&amp;amp;#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) print(app.config[&amp;amp;#39;SECRET_KEY&amp;amp;#39;]) instance = test() payload = { &amp;amp;#34;__init__&amp;amp;#34;:{ &amp;amp;#34;__globals__&amp;amp;#34;:{ &amp;amp;#34;app&amp;amp;#34;:{ &amp;amp;#34;config&amp;amp;#34;:{ &amp;amp;#34;SECRET_KEY&amp;amp;#34;:&amp;amp;#34;12SqweR&amp;amp;#34; } } } } } merge(payload, instance) print(app.config[&amp;amp;#39;SECRET_KEY&amp;amp;#39;]) 发现污染成功了，那么这里我们写个exp进行污染</description><content:encoded>0x01 这次很荣幸投稿了一题，大菜鸡师傅也收了，但是测题的时候，可能是我的污染功底不够扎实吧，有个非预期，这里给大家写一份详细的wp
0x02 ez_inject 预期 首先进入之后先注册，然后看到下面这几个页面
这样子一看肯定就是注册页面有污染了，但是在哪里呢，F12看看有啥东西
发现除了有 …</content:encoded></item><item><title>SHCTF2024</title><link>https://baozongwi.xyz/p/shctf2024/</link><guid>https://baozongwi.xyz/p/shctf2024/</guid><pubDate>Tue, 12 Nov 2024 09:41:57 +0000</pubDate><description>这是新生赛？</description><content:encoded>0x01 前言 这个比赛结束了，但是听说赛题质量挺高的来看看
0x02 question [Week1] 1zflask 访问robots.txt，拿到路由/s3recttt
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 …</content:encoded></item><item><title>强网杯2024</title><link>https://baozongwi.xyz/p/qiangwang-cup-2024/</link><guid>https://baozongwi.xyz/p/qiangwang-cup-2024/</guid><pubDate>Sat, 02 Nov 2024 09:31:08 +0000</pubDate><description>打着玩，反正当不了先锋</description><content:encoded>0x01 说在前面 打着玩，反正当不了先锋
0x02 question 签到 签到直接交就可以了
givemesecret 进来发现是TornadoServer/6.4.1
OK试试注入
然后中途stop，别看着只有一张图我可是锻炼了一早上呜呜呜
写写历程吧
1 从我要当主人-》我是工程师-》我是测 …</content:encoded></item><item><title>flask中的session伪造</title><link>https://baozongwi.xyz/p/flask-session-forgery/</link><guid>https://baozongwi.xyz/p/flask-session-forgery/</guid><pubDate>Tue, 22 Oct 2024 15:30:50 +0000</pubDate><description>0x01 说在前面 在一般的情况下，网站都会做一个简答的身份验证，而flask当中自然也有，这种就是我们常见的session，session是什么，可以看这个文章
1 https://baozongwi.xyz/2024/09/11/%E6%B5%85%E8%B0%88session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ 0x02 question 现在网上进行session伪造的很少有不需要key的几乎没有，所以这里推荐一个工具叫做flask-unsign，还有就是大家经常使用的脚本，不过我们先看一下结构
结构 先随便生成一个session
1 eyJsb2NhbGUiOiJlbiJ9-ZSDIwA-v5-mHM9ITAx5lbFhwa3jNnWTIYY Flask Session 的组成结构主要由三部分构成，第一部分为 Session Data ，即会话数据。第二部分为 Timestamp ，即时间戳。第三部分为 Cryptographic Hash ，即加密哈希。如下图
下面的结果是看P牛的博客知道的(他有代码)
json.dumps 将对象转换成json字符串，作为数据 如果数据压缩后长度更短，则用zlib库进行压缩 将数据用base64编码 通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割 签名只能防篡改不能防止被读取，所以我们只要有key就可以伪造cookie
解密代码 我们上面已经知道了逻辑，那么来分析一个脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env python3 import sys import zlib from base64 import b64decode from flask.sessions import session_json_serializer from itsdangerous import base64_decode def decryption(payload): payload, sig = payload.rsplit(b&amp;amp;#39;.&amp;amp;#39;, 1) payload, timestamp = payload.rsplit(b&amp;amp;#39;.&amp;amp;#39;, 1) decompress = False if payload.startswith(b&amp;amp;#39;.&amp;amp;#39;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&amp;amp;#39;Could not base64 decode the payload because of &amp;amp;#39; &amp;amp;#39;an exception&amp;amp;#39;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&amp;amp;#39;Could not zlib decompress the payload before &amp;amp;#39; &amp;amp;#39;decoding the payload&amp;amp;#39;) return session_json_serializer.loads(payload) if __name__ == &amp;amp;#39;__main__&amp;amp;#39;: print(decryption(&amp;amp;#34;eyJ1c2VybmFtZSI6eyIgYiI6IlozVmxjM1E9In19.XyZ3Vw.OcD3-l1yOcq8vlg8g4Ww3FxrhVs&amp;amp;#34;.encode())) 一步步来首先，用.给session分开，然后看看是否是压缩过的</description><content:encoded>0x01 说在前面 在一般的情况下，网站都会做一个简答的身份验证，而flask当中自然也有，这种就是我们常见的session，session是什么，可以看这个文章
1 …</content:encoded></item><item><title>DASCTF 2024金秋十月</title><link>https://baozongwi.xyz/p/dasctf-2024-golden-autumn-october/</link><guid>https://baozongwi.xyz/p/dasctf-2024-golden-autumn-october/</guid><pubDate>Sat, 19 Oct 2024 21:33:07 +0000</pubDate><description>0x01 前言 之前学到flask计算pin值的时候就知道一个1可以代替self，来进行文件读取，不过基本没用过，最近有个CTF，我不知道叫什么，cxcx师傅来和我交流说pin值说好了，如何进console，此时是400错误，我左思右想，想不到这啥情况，难不成不打pin值？结果最后就是读取了环境变量
0x02 question linux中/proc 官方文档是英文就不放了，简单的来说就是proc是一个伪文件系统，它提供了内核数据结构的接口。它通常挂载在 /proc 目录下。一般是由系统自动挂载的，不过也可以通过 mount 命令进行手动挂载。proc 文件系统只包含系统运行时的信息（如系统内存、mount 设备信息等），它只存在于内存中而不占用外存空间。它以文件系统的形式，为访问内核数据的操作提供接口。
但是其中的文件大部分为只读，只有少部分文件可写，我们可以通过可写文件来修改内核的部分配置
文件 /proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关
/proc/cmdline 启动时传递给kernel的参数信息
/proc/cpuinfo cpu的信息
/proc/crypto 内核使用的所有已安装的加密密码及细节
/proc/devices 已经加载的设备并分类
/proc/dma 已注册使用的ISA DMA频道列表
/proc/execdomains Linux内核当前支持的execution domains
/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动
/proc/filesystems 内核当前支持的文件系统类型
/proc/interrupts x86架构中的每个IRQ中断数
/proc/iomem 每个物理设备当前在系统内存中的映射
/proc/ioports 一个设备的输入输出所使用的注册端口范围
/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb
/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理
/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关
/proc/locks 内核锁住的文件列表
/proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)
/proc/meminfo RAM使用的相关信息
/proc/misc 其他的主要设备(设备号为10)上注册的驱动
/proc/modules 所有加载到内核的模块列表
/proc/mounts 系统中使用的所有挂载
/proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)
/proc/partitions 分区中的块分配信息
/proc/pci 系统中的PCI设备列表</description><content:encoded>0x01 前言 之前学到flask计算pin值的时候就知道一个1可以代替self，来进行文件读取，不过基本没用过，最近有个CTF，我不知道叫什么，cxcx师傅来和我交流说pin值说好了，如何进console，此时是400错误，我左思右想，想不到这啥情况，难不成不打pin值？ …</content:encoded></item><item><title>flask原型链污染</title><link>https://baozongwi.xyz/p/flask-prototype-pollution/</link><guid>https://baozongwi.xyz/p/flask-prototype-pollution/</guid><pubDate>Thu, 03 Oct 2024 16:57:12 +0000</pubDate><description>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的所有属性和方法，还可以添加新的属性和方法，或者重写父类的方法。
同时还有几个重要方法，这里直接引用一位师傅所写的
在Python中，定义类是通过class关键字，class后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的，所有类的本源都是object类 可以自由地给一个实例变量绑定属性，像js 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把类内置的属性绑上 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到 判断一个变量是否是某个类型可以用isinstance()判断。 普通继承 在子类中，你可以使用 super() 函数来调用父类的方法。这在子类需要扩展而不是完全重写父类方法时特别有用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Animal: def __init__(self, name): self.name = name def speak(self): raise NotImplementedError(&amp;amp;#34;Subclass must implement this abstract method&amp;amp;#34;) def eat(self): print(f&amp;amp;#34;{self.name} is eating.&amp;amp;#34;) class Dog(Animal): def __init__(self, name, breed): super().__init__(name) # 调用父类的构造函数 self.breed = breed def speak(self): print(f&amp;amp;#34;{self.name} says Woof!&amp;amp;#34;) def fetch(self): print(f&amp;amp;#34;{self.name} is fetching the ball.&amp;amp;#34;) class Cat(Animal): def __init__(self, name, color): super().__init__(name) # 调用父类的构造函数 self.color = color def speak(self): super().speak() # 调用父类的 speak 方法 print(f&amp;amp;#34;{self.name} says Meow!&amp;amp;#34;) def scratch(self): print(f&amp;amp;#34;{self.name} is scratching the furniture.&amp;amp;#34;) instance = Cat(&amp;amp;#34;无情&amp;amp;#34;,&amp;amp;#34;black&amp;amp;#34;) print(instance.name) 看看就行感觉没啥好讲的，看就能看懂</description><content:encoded>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的 …</content:encoded></item><item><title>SCTF2024</title><link>https://baozongwi.xyz/p/sctf2024/</link><guid>https://baozongwi.xyz/p/sctf2024/</guid><pubDate>Wed, 02 Oct 2024 11:17:26 +0000</pubDate><description>0x01 前言 又是变成劳大的一个周末
0x02 question ezrender 这里进入之后是一个登录框，本来是黑盒的，但是后面给了代码和提示
1 ulimit -n =2048 先把代码放出来吧
app.py
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 from flask import Flask, render_template, request, render_template_string,redirect from verify import * from User import User import base64 from waf import waf app = Flask(__name__,static_folder=&amp;amp;#34;static&amp;amp;#34;,template_folder=&amp;amp;#34;templates&amp;amp;#34;) user={} @app.route(&amp;amp;#39;/register&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;,&amp;amp;#34;GET&amp;amp;#34;]) def register(): method=request.method if method==&amp;amp;#34;GET&amp;amp;#34;: return render_template(&amp;amp;#34;register.html&amp;amp;#34;) if method==&amp;amp;#34;POST&amp;amp;#34;: data = request.get_json() name = data[&amp;amp;#34;username&amp;amp;#34;] pwd = data[&amp;amp;#34;password&amp;amp;#34;] if name != None and pwd != None: if data[&amp;amp;#34;username&amp;amp;#34;] in user: return &amp;amp;#34;This name had been registered&amp;amp;#34; else: user[name] = User(name, pwd) return &amp;amp;#34;OK&amp;amp;#34; @app.route(&amp;amp;#39;/login&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;,&amp;amp;#34;GET&amp;amp;#34;]) def login(): method=request.method if method==&amp;amp;#34;GET&amp;amp;#34;: return render_template(&amp;amp;#34;login.html&amp;amp;#34;) if method==&amp;amp;#34;POST&amp;amp;#34;: data = request.get_json() name = data[&amp;amp;#34;username&amp;amp;#34;] pwd = data[&amp;amp;#34;password&amp;amp;#34;] if name != None and pwd != None: if name not in user: return &amp;amp;#34;This account is not exist&amp;amp;#34; else: if user[name].pwd == pwd: token=generateToken(user[name]) return &amp;amp;#34;OK&amp;amp;#34;,200,{&amp;amp;#34;Set-Cookie&amp;amp;#34;:&amp;amp;#34;Token=&amp;amp;#34;+token} else: return &amp;amp;#34;Wrong password&amp;amp;#34; @app.route(&amp;amp;#39;/admin&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;,&amp;amp;#34;GET&amp;amp;#34;]) def admin(): try: token = request.headers.get(&amp;amp;#34;Cookie&amp;amp;#34;)[6:] except: return &amp;amp;#34;Please login first&amp;amp;#34; else: infor = json.loads(base64.b64decode(token)) name = infor[&amp;amp;#34;name&amp;amp;#34;] token = infor[&amp;amp;#34;secret&amp;amp;#34;] result = check(user[name], token) method=request.method if method==&amp;amp;#34;GET&amp;amp;#34;: return render_template(&amp;amp;#34;admin.html&amp;amp;#34;,name=name) if method==&amp;amp;#34;POST&amp;amp;#34;: template = request.form.get(&amp;amp;#34;code&amp;amp;#34;) if result != &amp;amp;#34;True&amp;amp;#34;: return result, 401 #just only blackList if waf(template): return &amp;amp;#34;Hacker Found&amp;amp;#34; result=render_template_string(template) print(result) if result !=None: return &amp;amp;#34;OK&amp;amp;#34; else: return &amp;amp;#34;error&amp;amp;#34; @app.route(&amp;amp;#39;/&amp;amp;#39;, methods=[&amp;amp;#34;GET&amp;amp;#34;]) def index(): return redirect(&amp;amp;#34;login&amp;amp;#34;) @app.route(&amp;amp;#39;/removeUser&amp;amp;#39;, methods=[&amp;amp;#34;POST&amp;amp;#34;]) def remove(): try: token = request.headers.get(&amp;amp;#34;Cookie&amp;amp;#34;)[6:] except: return &amp;amp;#34;Please login first&amp;amp;#34; else: infor = json.loads(base64.b64decode(token)) name = infor[&amp;amp;#34;name&amp;amp;#34;] token = infor[&amp;amp;#34;secret&amp;amp;#34;] result = check(user[name], token) if result != &amp;amp;#34;True&amp;amp;#34;: return result, 401 rmuser=request.form.get(&amp;amp;#34;username&amp;amp;#34;) user.pop(rmuser) return &amp;amp;#34;Successfully Removed:&amp;amp;#34;+rmuser if __name__ == &amp;amp;#39;__main__&amp;amp;#39;: # for the safe del __builtins__.__dict__[&amp;amp;#39;eval&amp;amp;#39;] app.run(debug=False, host=&amp;amp;#39;0.0.0.0&amp;amp;#39;, port=8080) User.py</description><content:encoded>0x01 前言 又是变成劳大的一个周末
0x02 question ezrender 这里进入之后是一个登录框，本来是黑盒的，但是后面给了代码和提示
1 ulimit -n =2048 先把代码放出来吧
app.py
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 …</content:encoded></item><item><title>BaseCTF</title><link>https://baozongwi.xyz/p/basectf/</link><guid>https://baozongwi.xyz/p/basectf/</guid><pubDate>Mon, 16 Sep 2024 12:07:24 +0000</pubDate><description>0x01 前言 比赛都结束了，但是我还是写一下WP吧，学到了挺多东西的，只打了前两周，后面开学了自己还要学一些东西，所以就没打了，气人的是，上个月底成都太热了，我写了两周的WP，居然热关机电脑没存上，啊啊啊
0x02 WP [Week1] A Dark Room 查看源码
[Week1] Aura 酱的礼物 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 &amp;amp;lt;?php highlight_file(__FILE__); // Aura 酱，欢迎回家~ // 这里有一份礼物，请你签收一下哟~ $pen = $_POST[&amp;amp;#39;pen&amp;amp;#39;]; if (file_get_contents($pen) !== &amp;amp;#39;Aura&amp;amp;#39;) { die(&amp;amp;#39;这是 Aura 的礼物，你不是 Aura！&amp;amp;#39;); } // 礼物收到啦，接下来要去博客里面写下感想哦~ $challenge = $_POST[&amp;amp;#39;challenge&amp;amp;#39;]; if (strpos($challenge, &amp;amp;#39;http://jasmineaura.github.io&amp;amp;#39;) !== 0) { die(&amp;amp;#39;这不是 Aura 的博客！&amp;amp;#39;); } $blog_content = file_get_contents($challenge); if (strpos($blog_content, &amp;amp;#39;已经收到Kengwang的礼物啦&amp;amp;#39;) === false) { die(&amp;amp;#39;请去博客里面写下感想哦~&amp;amp;#39;); } // 嘿嘿，接下来要拆开礼物啦，悄悄告诉你，礼物在 flag.php 里面哦~ $gift = $_POST[&amp;amp;#39;gift&amp;amp;#39;]; include($gift); 这是 Aura 的礼物，你不是 Aura！ @重定向一下即可</description><content:encoded>0x01 前言 比赛都结束了，但是我还是写一下WP吧，学到了挺多东西的，只打了前两周，后面开学了自己还要学一些东西，所以就没打了，气人的是，上个月底成都太热了，我写了两周的WP，居然热关机电脑没存上，啊啊啊
0x02 WP [Week1] A Dark Room 查看源码
[Week1] Aura …</content:encoded></item><item><title>浅析flask内存马</title><link>https://baozongwi.xyz/p/flask-memory-shell-analysis/</link><guid>https://baozongwi.xyz/p/flask-memory-shell-analysis/</guid><pubDate>Mon, 02 Sep 2024 11:03:56 +0000</pubDate><description>你学SSTI不学内存马？</description><content:encoded>0x01 前言 flask中的SSTI注入或许是个好姿势，但是我能不能getshell呢,之前经常阅读联队写的大赛WP,&amp;amp;amp;ldquo;写个脚本打入内存马&amp;amp;amp;rdquo;，好高级，好想学，那今天我来看看这到底是个什么乾坤
0x02 question flask现在已经更新换代了，但是我觉得仍然值得学习， …</content:encoded></item><item><title>浅析flask中的SSTI漏洞</title><link>https://baozongwi.xyz/p/flask-ssti-vulnerability-analysis/</link><guid>https://baozongwi.xyz/p/flask-ssti-vulnerability-analysis/</guid><pubDate>Sun, 01 Sep 2024 09:51:44 +0000</pubDate><description>SSTI吗</description><content:encoded>0x01 前言 或许这里说成是flask并不妥当，因为仅仅只是讲解了jinja这种常用的SSti漏洞,但是其实payload都是大同小异，那就这样吧
0x02 question 概念 SSTI（Server-Side Template Injection，服务器端模板注入）漏洞是一种网络安全漏洞，发 …</content:encoded></item><item><title>NepCTF2024</title><link>https://baozongwi.xyz/p/nepctf2024/</link><guid>https://baozongwi.xyz/p/nepctf2024/</guid><pubDate>Wed, 28 Aug 2024 15:27:40 +0000</pubDate><description>别太努力没什么用</description><content:encoded>0x01 前言 算是第一次参加联队的比赛，虽然成绩不是特别好但是很开心，因为一直在进步！！
0x02 questions NepMagic —— CheckIn 狠狠的玩游戏就行了，中途注意一下,x是背包
Nemophila 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 …</content:encoded></item><item><title>flask计算pin值</title><link>https://baozongwi.xyz/p/flask-pin-calculation/</link><guid>https://baozongwi.xyz/p/flask-pin-calculation/</guid><pubDate>Mon, 19 Aug 2024 09:09:00 +0000</pubDate><description>0x01 前言 最近有道flask不仅仅可以绕过黑名单而且开启了debug模式可以进行pin值计算getshell
0x02 原理 pin码是flask在开启debug模式下，进行代码调试模式所需的进入密码，需要正确的PIN码才能进入调试模式,可以理解为自带的webshell
计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 probably_public_bits = [ username 运行当前程序的用户名 modname 当前对象的模块名，默认为flask.app getattr(app, &amp;amp;#34;__name__&amp;amp;#34;, app.__class__.__name__) 当前对象的名称，默认为Flask getattr(mod, &amp;amp;#34;__file__&amp;amp;#34;, None) flask包内的app.py的绝对路径 ] private_bits = [ str(uuid.getnode()) Mac地址的整型，通过int(Mac, 16)可以获取 get_machine_id() [ docker /proc/self/cgroup，正则分割 Linux /etc/machine-id，/proc/sys/kernl/random/boot_id，前者固定后者不固定 macOS ioreg -c IOPlatformExpertDevice -d 2中&amp;amp;#34;serial-number&amp;amp;#34; = &amp;amp;lt;{ID}部分 Windows 注册表HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Cryptography/MachineGuid ] ] 那么我们主要研究如何得到docker的相关</description><content:encoded>0x01 前言 最近有道flask不仅仅可以绕过黑名单而且开启了debug模式可以进行pin值计算getshell
0x02 原理 pin码是flask在开启debug模式下，进行代码调试模式所需的进入密码，需要正确的PIN码才能进入调试模式,可以理解为自带的webshell
计算 1 2 3 4 …</content:encoded></item><item><title>巅峰极客2024</title><link>https://baozongwi.xyz/p/peak-geek-2024/</link><guid>https://baozongwi.xyz/p/peak-geek-2024/</guid><pubDate>Sat, 17 Aug 2024 17:40:28 +0000</pubDate><description>0x01 前言 前两天看了巅峰赛，自己也还行，不像之前一样爆零了至少，记录一下
0x02 题目 EncirclingGame 玩游戏就可以了，别点太快了围起来就可以了
GoldenHornKing 一个SSTI漏洞但是不同往常，尝试了很久
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import os import jinja2 import functools import uvicorn from fastapi import FastAPI from fastapi.templating import Jinja2Templates from anyio import fail_after, sleep # jinja2==3.1.2 # uvicorn==0.30.5 # fastapi==0.112.0 def timeout_after(timeout: int = 1): def decorator(func): @functools.wraps(func) async def wrapper(*args, **kwargs): with fail_after(timeout): return await func(*args, **kwargs) return wrapper return decorator app = FastAPI() access = False _base_path = os.path.dirname(os.path.abspath(__file__)) t = Jinja2Templates(directory=_base_path) @app.get(&amp;amp;#34;/&amp;amp;#34;) @timeout_after(1) async def index(): return open(__file__, &amp;amp;#39;r&amp;amp;#39;).read() @app.get(&amp;amp;#34;/calc&amp;amp;#34;) @timeout_after(1) async def ssti(calc_req: str ): global access if (any(char.isdigit() for char in calc_req)) or (&amp;amp;#34;%&amp;amp;#34; in calc_req) or not calc_req.isascii() or access: return &amp;amp;#34;bad char&amp;amp;#34; else: jinja2.Environment(loader=jinja2.BaseLoader()).from_string(f&amp;amp;#34;{{{{ {calc_req} }}}}&amp;amp;#34;).render({&amp;amp;#34;app&amp;amp;#34;: app}) access = True return &amp;amp;#34;fight&amp;amp;#34; if __name__ == &amp;amp;#34;__main__&amp;amp;#34;: uvicorn.run(app, host=&amp;amp;#34;0.0.0.0&amp;amp;#34;, port=8000) 看了一下代码发现只能打一次，打完就得刷机</description><content:encoded>0x01 前言 前两天看了巅峰赛，自己也还行，不像之前一样爆零了至少，记录一下
0x02 题目 EncirclingGame 玩游戏就可以了，别点太快了围起来就可以了
GoldenHornKing 一个SSTI漏洞但是不同往常，尝试了很久
1 2 3 4 5 6 7 8 9 10 11 12 13 …</content:encoded></item></channel></rss>