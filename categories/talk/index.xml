<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>baozongwi's blog</title><link>https://baozongwi.xyz/categories/talk/</link><description>baozongwi's blog</description><lastBuildDate>Fri, 20 Feb 2026 20:57:03 +0800</lastBuildDate><atom:link href="https://baozongwi.xyz/categories/talk/" rel="self" type="application/rss+xml"/><item><title>Burpsuite插件</title><link>https://baozongwi.xyz/p/burpsuite-extensions/</link><guid>https://baozongwi.xyz/p/burpsuite-extensions/</guid><pubDate>Thu, 01 Jan 2026 15:36:45 +0800</pubDate><description>戒了 yakit 之后发现burp有些方面确实没那么顺手，于是自己写了两个插件，个人觉得挺好用的，欢迎大家star，JPython 这个jar包也是官网的，可以直接使用，后续应该有需求还会继续写。
https://github.com/baozongwi/BurpExtensions
加载 JPython
add 插件</description><content:encoded>戒了 yakit 之后发现burp有些方面确实没那么顺手，于是自己写了两个插件，个人觉得挺好用的，欢迎大家star，JPython 这个jar包也是官网的，可以直接使用，后续应该有需求还会继续写。
https://github.com/baozongwi/BurpExtensions …</content:encoded></item><item><title>Vulhub复现学习</title><link>https://baozongwi.xyz/p/vulhub-reproduction/</link><guid>https://baozongwi.xyz/p/vulhub-reproduction/</guid><pubDate>Wed, 10 Dec 2025 08:48:14 +0800</pubDate><description>
在这里学到了 Java-chains 的使用，了解了各种漏洞复现，但是还是不知道每个应用能在生产环境中能干嘛，以及合理的修复😣</description><content:encoded>
在这里学到了 Java-chains 的使用，了解了各种漏洞复现，但是还是不知道每个应用能在生产环境中能干嘛，以及合理的修复😣</content:encoded></item><item><title>加速博客折腾记</title><link>https://baozongwi.xyz/p/blog-performance-optimization/</link><guid>https://baozongwi.xyz/p/blog-performance-optimization/</guid><pubDate>Sun, 23 Nov 2025 16:25:23 +0800</pubDate><description>最终当然还是持续利用Vps😋</description><content:encoded>Deno https://dash.deno.com/tutorial/tutorial-http
new一个playground
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const …</content:encoded></item><item><title>Markdown瞬间转移图片脚本</title><link>https://baozongwi.xyz/p/markdown-image-teleport-script/</link><guid>https://baozongwi.xyz/p/markdown-image-teleport-script/</guid><pubDate>Tue, 18 Nov 2025 00:43:17 +0800</pubDate><description>自用的，一般誊抄 SU 的 Writeup 总是会消耗很久时间，主要就是从飞书下载图片到博客文件夹内，然后再在markdown 文章中让其生效，虽然下载图片的过程我省略不了，但是转移的话可以省下不少时间。
与此同时我也已经变成了懒人，也不说是懒，因为有两个电脑，所以我通常使用语雀作为他们的媒介，也是誊抄到本地博客，所以这个脚本也会让我方便很多😜
首先直接从语雀或者飞书复制到md文档，然后使用脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import re import argparse from pathlib import Path def find_max_used_index(text, folder, ext): no_prefix = folder.strip() in (&amp;amp;#34;.&amp;amp;#34;, &amp;amp;#34;./&amp;amp;#34;) if no_prefix: pat = re.compile(r&amp;amp;#34;!\[[^\]]*\]\((?:\./)?([0-9]+)\.&amp;amp;#34; + re.escape(ext) + r&amp;amp;#34;\)&amp;amp;#34;) else: pat = re.compile(r&amp;amp;#34;!\[[^\]]*\]\(&amp;amp;#34; + re.escape(folder.rstrip(&amp;amp;#39;/&amp;amp;#39;)) + r&amp;amp;#34;/([0-9]+)\.&amp;amp;#34; + re.escape(ext) + r&amp;amp;#34;\)&amp;amp;#34;) max_idx = -1 for m in pat.finditer(text): i = int(m.group(1)) if i &amp;amp;gt; max_idx: max_idx = i return max_idx def replace_feishu_images(text, folder, start, end, alt, ext): remote_img_pat = re.compile(r&amp;amp;#34;!\[[^\]]*\]\((https://[^)]*)\)&amp;amp;#34;) idx = start limit = end if end is not None else None no_prefix = folder.strip() in (&amp;amp;#34;.&amp;amp;#34;, &amp;amp;#34;./&amp;amp;#34;) def repl(_): nonlocal idx if limit is not None and idx &amp;amp;gt; limit: return _.group(0) if no_prefix: s = f&amp;amp;#34;![{alt}]({idx}.{ext})&amp;amp;#34; else: s = f&amp;amp;#34;![{alt}]({folder.rstrip(&amp;amp;#39;/&amp;amp;#39;)}/{idx}.{ext})&amp;amp;#34; idx += 1 return s return remote_img_pat.sub(repl, text) def main(): p = argparse.ArgumentParser() p.add_argument(&amp;amp;#39;--md&amp;amp;#39;, required=True) p.add_argument(&amp;amp;#39;--folder&amp;amp;#39;, required=True) p.add_argument(&amp;amp;#39;--start&amp;amp;#39;, type=int) p.add_argument(&amp;amp;#39;--end&amp;amp;#39;, type=int) p.add_argument(&amp;amp;#39;--alt&amp;amp;#39;, default=&amp;amp;#39;img&amp;amp;#39;) p.add_argument(&amp;amp;#39;--ext&amp;amp;#39;, default=&amp;amp;#39;png&amp;amp;#39;) p.add_argument(&amp;amp;#39;--dry&amp;amp;#39;, action=&amp;amp;#39;store_true&amp;amp;#39;) args = p.parse_args() md_path = Path(args.md) text = md_path.read_text(encoding=&amp;amp;#39;utf-8&amp;amp;#39;) start = args.start if start is None: max_used = find_max_used_index(text, args.folder, args.ext) start = max_used + 1 if max_used &amp;amp;gt;= 0 else 0 new_text = replace_feishu_images(text, args.folder, start, args.end, args.alt, args.ext) if args.dry: print(new_text) else: md_path.write_text(new_text, encoding=&amp;amp;#39;utf-8&amp;amp;#39;) if __name__ == &amp;amp;#39;__main__&amp;amp;#39;: main() # python replace_feishu_images.py --md index.md --folder . --start 1 --end 14 --ext png # python replace_feishu_images.py --md 2025-RCTF.md --folder ../images/2025-RCTF --start 0 --end 76 --ext png RCTF 总共有 0-76,77 张 png，然后可以识别到再瞬间转换，就不用一步步的来誊抄了。</description><content:encoded>自用的，一般誊抄 SU 的 Writeup 总是会消耗很久时间，主要就是从飞书下载图片到博客文件夹内，然后再在markdown 文章中让其生效，虽然下载图片的过程我省略不了，但是转移的话可以省下不少时间。
与此同时我也已经变成了懒人，也不说是懒，因为有两个电脑，所以我通常使用语雀作为他们的媒介，也是 …</content:encoded></item><item><title>关于我使用Trae优化Stack这件事</title><link>https://baozongwi.xyz/p/trae-optimize-stack/</link><guid>https://baozongwi.xyz/p/trae-optimize-stack/</guid><pubDate>Thu, 13 Nov 2025 01:42:52 +0800</pubDate><description>现在的博客真是越来越顺眼了😝</description><content:encoded>昨天下午，在公司闲来无事，想着自己的博客主题 Stack 有很多小细节都不满意，最近用 Trae 这个 MCP Tools 也越来越顺手，于是我想着要不就微微的优化一下自己的主题？
说干就干，优化的功能如下：
首先要优化的就是图片的灯窗，由于之前有个灯窗，但是那个功能我是不需要的，而且主题渲染文章中 …</content:encoded></item><item><title>线下出网配置</title><link>https://baozongwi.xyz/p/internal-network-egress/</link><guid>https://baozongwi.xyz/p/internal-network-egress/</guid><pubDate>Tue, 28 Oct 2025 19:42:35 +0800</pubDate><description>请求支援</description><content:encoded>当比赛可以出网的时候，我们可以同时插着网线，以及链接WIFI使用，只需要进行一个设置。
分别对以太网和 WiFi 进行跃点设置，值越小越优先。
同时，有时候靶机不在同一个网段，我们需要添加静态路由，
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 …</content:encoded></item><item><title>K8s Remote Api未授权利用</title><link>https://baozongwi.xyz/p/kubernetes-remote-api-unauthorized/</link><guid>https://baozongwi.xyz/p/kubernetes-remote-api-unauthorized/</guid><pubDate>Wed, 01 Oct 2025 10:01:15 +0800</pubDate><description>集群搭建让我红温🥵</description><content:encoded>环境搭建 6443、8080、10250端口未授权利用漏洞
搭建k8s集群🥵，这里卡了很久。我是真的红温了🤬（byd用引用的文章里面写的根本不行）
**k8s1.16.0以下版本默认启用8080端口（无认证）。**我们只需要用一个不弃用8080端口的再修改配置就可以了
1 ./metarget …</content:encoded></item><item><title>Kubernetes基础入门使用</title><link>https://baozongwi.xyz/p/kubernetes-getting-started-tutorial/</link><guid>https://baozongwi.xyz/p/kubernetes-getting-started-tutorial/</guid><pubDate>Mon, 29 Sep 2025 09:04:12 +0800</pubDate><description>概念 现在国内的安全越来越少的传统AD了，所以k8s是不可能越过的坎，必须来了解学习一下。包括现在很多的CTF平台其实都更倾向于使用轻量k8s(k3s)。
Kubernetes是一个可以移植、可扩展的开源平台，使用声明式配置并依据配置信息自动地执行容器化应用程序的管理。在所有的容器编排工具中（类似的还有 docker swarm / mesos等），Kubernetes的生态系统更大、增长更快，有更多的支持、服务和工具可供用户选择。
其中，声明式配置就是使用yaml等文件明确定义应用等期望状态，这样的好处是什么呢？
Kubernetes 的控制器（如 Deployment Controller）持续比较 当前状态 和 声明中期望的状态 。 若不一致（如Pod崩溃导致副本数不足），自动触发修复（如新建Pod）。 传统部署时代：早期，企业直接将应用程序部署在物理机上。由于物理机上不能为应用程序定义资源使用边界，我们也就很难合理地分配计算资源。例如：如果多个应用程序运行在同一台物理机上，可能发生这样的情况：其中的一个应用程序消耗了大多数的计算资源，导致其他应用程序不能正常运行。应对此问题的一种解决办法是，将每一个应用程序运行在不同的物理机上。然而，这种做法无法大规模实施，因为资源利用率很低，且企业维护更多物理机的成本昂贵。
虚拟化部署时代：针对上述问题，虚拟化技术应运而生。用户可以在单台物理机的CPU上运行多个虚拟机（Virtual Machine）。
虚拟化技术使得应用程序被虚拟机相互分隔开，限制了应用程序之间的非法访问，进而提供了一定程度的安全性。
虚拟化技术提高了物理机的资源利用率，可以更容易地安装或更新应用程序，降低了硬件成本，因此可以更好地规模化实施。
每一个虚拟机可以认为是被虚拟化的物理机之上的一台完整的机器，其中运行了一台机器的所有组件，包括虚拟机自身的操作系统。
容器化部署时代：容器与虚拟机类似，但是降低了隔离层级，共享了操作系统。因此，容器可以认为是轻量级的。
与虚拟机相似，每个容器拥有自己的文件系统、CPU、内存、进程空间等
运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦
容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署
🥺我们平时直接在服务器或者是虚拟机上面起docker复现就是第一种，相当操蛋了，如果你起了一个较大的容器，其他容器服务可能就遭不住了，甚至你的服务器也会白给(别问，我知道
我们在自己电脑上面安装虚拟机就是第二种，而第三种就是本文，小包所学习的。第三种的好处可就是多多的了，如下：
容器技术通过轻量化、标准化和自动化 ，显著提升了应用开发和部署的效率与灵活性。相较于虚拟机，容器镜像的构建和部署更快速敏捷 ，支持持续集成与回滚，同时解耦开发与运维 ——开发聚焦应用构建，运维专注基础设施。容器提供环境一致性 ，确保开发、测试、生产环境无缝衔接，并具备跨云跨平台 的可移植性。它以应用为中心 ，优化资源隔离与利用率，支持弹性微服务架构 ，使分布式应用更易扩展和维护，同时通过细粒度监控保障应用健康。
基础组件 Master组件 Master组件是集群的控制平台（control plane）：
master 组件负责集群中的全局决策（例如，调度） master 组件探测并响应集群事件（例如，当 Deployment 的实际 Pod 副本数未达到 replicas 字段的规定时，启动一个新的 Pod） Master组件可以运行于集群中的任何机器上。但是，为了简洁性，通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器，这就是master节点。
kube-apiserver如下：
此 master 组件提供 Kubernetes API。这是Kubernetes控制平台的前端（front-end），可以水平扩展（通过部署更多的实例以达到性能要求）。kubectl / kubernetes dashboard / kuboard 等Kubernetes管理工具就是通过 kubernetes API 实现对 Kubernetes 集群的管理。</description><content:encoded>概念 现在国内的安全越来越少的传统AD了，所以k8s是不可能越过的坎，必须来了解学习一下。包括现在很多的CTF平台其实都更倾向于使用轻量k8s(k3s)。
Kubernetes是一个可以移植、可扩展的开源平台，使用声明式配置并依据配置信息自动地执行容器化应用程序的管理。在所有的容器编排工具中（类似的 …</content:encoded></item><item><title>不出网compose编写</title><link>https://baozongwi.xyz/p/docker-compose-no-egress/</link><guid>https://baozongwi.xyz/p/docker-compose-no-egress/</guid><pubDate>Wed, 24 Sep 2025 01:02:13 +0800</pubDate><description>之前年初SUCTF的时候，毕师傅因为余神写的Docker不够权威，导致了DNS出网，直接可以把flag给leak出来，后来我也没解决DNS出网的问题，直到有一次让infer出题的时候他知道怎么弄
一般我是直接把DNS设置为空，但是这样子还是能出网，而要不出网的话，需要设置为127.0.0.1
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 services: test: image: test:latest build: context: . dockerfile: Dockerfile ports: - &amp;amp;#34;8000:8000&amp;amp;#34; restart: unless-stopped deploy: resources: limits: memory: 512M cpus: &amp;amp;#39;0.5&amp;amp;#39; environment: - PYTHONUNBUFFERED=1 tmpfs: - /tmp:size=100M,noexec,nosuid,nodev dns: - 127.0.0.1 cap_drop: - ALL cap_add: - SETUID - SETGID - CHOWN networks: - private networks: private: driver: bridge driver_opts: com.docker.network.bridge.enable_ip_masquerade: &amp;amp;#39;false&amp;amp;#39; 只要用这个compose启动的容器，那确实是不出网的，但是我给image导出为tar再导入使用的时候发现tar导入的镜像直接启动的容器依旧是出网的，使用命令为</description><content:encoded>之前年初SUCTF的时候，毕师傅因为余神写的Docker不够权威，导致了DNS出网，直接可以把flag给leak出来，后来我也没解决DNS出网的问题，直到有一次让infer出题的时候他知道怎么弄
一般我是直接把DNS设置为空，但是这样子还是能出网，而要不出网的话，需要设置为127.0.0.1
1 2 …</content:encoded></item><item><title>Redis未授权利用</title><link>https://baozongwi.xyz/p/redis-unauthorized-access-exploit/</link><guid>https://baozongwi.xyz/p/redis-unauthorized-access-exploit/</guid><pubDate>Mon, 22 Sep 2025 20:24:20 +0800</pubDate><description>经常打的redis，经常催的redis🤔</description><content:encoded>redis未授权利用，确认其是否存活
1 2 3 redis-cli -h &amp;amp;amp;lt;Target-IP&amp;amp;amp;gt; -p &amp;amp;amp;lt;Target-Port&amp;amp;amp;gt; info 可以说是最火热的姿势了，经常用到，这里我介绍几种我知道的
写入文件&amp;amp;amp;amp;&amp;amp;amp;amp;其他 这里分很多种，得知web根目录写 …</content:encoded></item><item><title>Docker Remote Api 未授权利用</title><link>https://baozongwi.xyz/p/docker-remote-api-unauthorized-access-exploit/</link><guid>https://baozongwi.xyz/p/docker-remote-api-unauthorized-access-exploit/</guid><pubDate>Mon, 22 Sep 2025 20:20:51 +0800</pubDate><description>概念 一位大佬使用docker swarm管理docker集群的时候，发现了管理的docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page not found，然后他研究了下，发现这是 Docker Remote API，可以执行docker命令，比如访问 http://host:2375/containers/json 会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，其他操作比如创建/删除container，拉取image等操作也都可以通过API调用完成。（不是哥们）
Docker Remote API 是 Docker 提供的 RESTful 接口 ，默认绑定 2375（非加密）和 2376（TLS 加密）端口，用于远程管理 Docker 容器、镜像、网络等资源。 当管理员错误配置 允许未授权访问 （如直接暴露 0.0.0.0:2375），攻击者可通过该 API 完全控制 Docker 环境 ，进而实现 容器逃逸 ，最终接管宿主机。
对于docker中的通信流程，有以下几个重要组件
组件 作用 Docker Client 用户使用的命令行工具（如 **docker ps**），通过 API 与 Daemon 交互。 Docker Daemon 后台服务（**dockerd**），实际管理容器、镜像、存储等资源。 Docker Remote API 提供 REST 接口（默认 **2375** 端口），接收 Client 或 HTTP 请求。</description><content:encoded>概念 一位大佬使用docker swarm管理docker集群的时候，发现了管理的docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page not found，然后他研究了下，发现这是 Docker Remote API，可以执行docker命 …</content:encoded></item><item><title>next主题优化(bug修复)</title><link>https://baozongwi.xyz/p/next-theme-optimization-bug-fixes/</link><guid>https://baozongwi.xyz/p/next-theme-optimization-bug-fixes/</guid><pubDate>Sun, 10 Aug 2025 10:04:10 +0000</pubDate><description>搜索bug修复、友链新增、waline评论</description><content:encoded>在我换了新主题之后，我发现有一个非常影响我个人使用的bug，就是搜索功能缺陷。打个比方，我有200篇文章，但是他貌似是只能检索前100篇，去年写的100篇就完全搜索不到了，并且每个主题好像都有bug是说搜索关键词之后，文章内容和文章标题优先级是等同的，这个非常不好，因为大部分技术就这样了，比方 …</content:encoded></item><item><title>LinuxAmd64中suid位实现提权</title><link>https://baozongwi.xyz/p/linux-amd64-suid-privilege-escalation/</link><guid>https://baozongwi.xyz/p/linux-amd64-suid-privilege-escalation/</guid><pubDate>Sun, 03 Aug 2025 18:19:43 +0000</pubDate><description>suid位还是花</description><content:encoded>周末和suers一起看了两个提权的题目，出自justCTF2025。
PyEvaline crimes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &amp;amp;amp;lt;stdio.h&amp;amp;amp;gt; #include …</content:encoded></item><item><title>Ligolo-ng搭建内网TUN模式代理</title><link>https://baozongwi.xyz/p/ligolo-ng-intranet-tun-proxy-setup/</link><guid>https://baozongwi.xyz/p/ligolo-ng-intranet-tun-proxy-setup/</guid><pubDate>Mon, 09 Jun 2025 20:52:43 +0000</pubDate><description>非常好用的代理工具</description><content:encoded>https://github.com/nicocha30/ligolo-ng/
说在前面 今天玩云镜的时候，和Byxs20师傅一起打了一个靶场，聊了聊一些工具，他给我推荐了这个来搭建代理，其实本来不是很情愿使用这个东西的，但是他toDesk给我硬塞了，分享到SU群里面，原来eson哥早就告诉我了这个 …</content:encoded></item><item><title>sanic内存马</title><link>https://baozongwi.xyz/p/sanic-memory-shell/</link><guid>https://baozongwi.xyz/p/sanic-memory-shell/</guid><pubDate>Tue, 27 May 2025 15:35:40 +0000</pubDate><description>pickle反序列化的时候应该挺有用的吧</description><content:encoded>直接开始，首先就是测试代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from sanic import Sanic from sanic.response import json,text app = Sanic(&amp;amp;amp;#34;hello&amp;amp;amp;#34;) …</content:encoded></item><item><title>动调挖掘pop</title><link>https://baozongwi.xyz/p/dynamic-debugging-pop-discovery/</link><guid>https://baozongwi.xyz/p/dynamic-debugging-pop-discovery/</guid><pubDate>Thu, 08 May 2025 09:42:06 +0000</pubDate><description>PX的时候发现还能这么整</description><content:encoded>前言 今年NCTF的时候有一位师傅来问过我一个很好的问题，当时我自己也不是很会，也不知道该如何去回答这个问题
你们这些大佬都是怎么找到这些新特性的呀，比如这次的原型链污染，我怎么知道要污染这个属性呢
看过我CTFshow之thinkphp专题的文章的师傅应该看的出来，那里面的分析其实我都是静态分析， …</content:encoded></item><item><title>sqlmap使用</title><link>https://baozongwi.xyz/p/sqlmap-usage/</link><guid>https://baozongwi.xyz/p/sqlmap-usage/</guid><pubDate>Mon, 05 May 2025 09:33:13 +0000</pubDate><description>当脚本小子的第一步</description><content:encoded>安装 工具这类的东西肯定是越新越好，所以建议是git安装
1 2 3 git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev cd sqlmap-dev python3 sqlmap.py --help 其 …</content:encoded></item><item><title>ctfshowSql注入</title><link>https://baozongwi.xyz/p/ctfshow-sql-injection/</link><guid>https://baozongwi.xyz/p/ctfshow-sql-injection/</guid><pubDate>Tue, 29 Apr 2025 16:33:07 +0000</pubDate><description>SQL注入练习</description><content:encoded>有一些师傅在去年就开始看我博客了，但是我还弄了一个每月计划，其中我最想写的是mysql注入，当时草草的看了看狗哥写的一篇文章让我看的也很想写，很想记录一下这些东西，顺便练习一下如何去写脚本，恰逢这几天，有不少师傅都在问，我就从ctfshow的SQL注入模块来学习一下一些有趣的姿势，简单的写写exp …</content:encoded></item><item><title>certbot配置https</title><link>https://baozongwi.xyz/p/certbot-https-configuration/</link><guid>https://baozongwi.xyz/p/certbot-https-configuration/</guid><pubDate>Wed, 16 Apr 2025 21:57:48 +0000</pubDate><description>让你不用担心https</description><content:encoded>说在前面 首先声明一下，这并不是水文，起因是今天下午突然想起来，dice2024的时候有一道题因为自己的域名不够短，而没能攻击成功，想来就气，于是去阿里云淘到了一个非常不错的域名，rb3.top十年188，简直拉满了，我也是用了一个小时才找到的，想用来专门给一台服务器当做测试的攻击机，但是https …</content:encoded></item><item><title>gopherus工具剖析</title><link>https://baozongwi.xyz/p/gopherus-tool-analysis/</link><guid>https://baozongwi.xyz/p/gopherus-tool-analysis/</guid><pubDate>Mon, 31 Mar 2025 13:46:16 +0000</pubDate><description>没整明白</description><content:encoded>说在前面 在软件安全赛的时候有一道较为简单的redisSSRF漏洞，有师傅问我，但是当时并不是很有空，后面在网上找文章(特别是国光师傅的SSRF打穿内网)，发现了一些之前不知道的东西
协议了解 SSRF的利用主要与协议相关，有很多，但是这里只说说经常用的
file\phar …</content:encoded></item><item><title>uptime-kuma部署使用</title><link>https://baozongwi.xyz/p/uptime-kuma-deployment-usage/</link><guid>https://baozongwi.xyz/p/uptime-kuma-deployment-usage/</guid><pubDate>Thu, 20 Mar 2025 21:50:56 +0000</pubDate><description>监控自己的服务</description><content:encoded>在网上经常看到博客里面有个状态页，美美看到这个，我就非常好奇\喜欢\想要，或许这个东西现在是用不上的，但是我就是想建一个，这里选择使用docker来搭建项目源码
docker搭建服务 docker怎么安装不说了，在我博客search一下就可以了，
1 2 3 4 5 6 docker run -d …</content:encoded></item><item><title>CTFd搭建</title><link>https://baozongwi.xyz/p/ctfd-setup/</link><guid>https://baozongwi.xyz/p/ctfd-setup/</guid><pubDate>Mon, 17 Mar 2025 15:47:27 +0000</pubDate><description>刷</description><content:encoded>你问我为什么又要搭建CTFd了，因为我打了两个月的国际赛了发现外面还是用的CTFd，当然你如果要使用动态靶机的话，要使用赵总的插件，那样子CTFd根本承受不住，所以如果使用的是静态靶机，比如校赛的话，就用CTFd比较简单方便
docker安装&amp;amp;amp;amp;&amp;amp;amp;amp;换源 之前的文章，基础使用docker …</content:encoded></item><item><title>内网穿透Windows&amp;&amp;代理搭建</title><link>https://baozongwi.xyz/p/intranet-penetration-windows-proxy-setup/</link><guid>https://baozongwi.xyz/p/intranet-penetration-windows-proxy-setup/</guid><pubDate>Thu, 13 Mar 2025 19:26:46 +0000</pubDate><description>酒店学的，网上没人发过怎么用Stowaway正向代理，我应该是首发吧？</description><content:encoded>因为局域网不能连接服务器，所以必须把本机穿透了，或者是将虚拟机的端口进行转发，这里记录一下自己的学习过程
花生壳穿透 这里选择的是大家都在说的花生壳来进行穿透，但是网上我看有好几个网站，官网应该是这个贝锐花生壳 进入之后注册登录账号下载花生壳，
下载好了之后就点击这个，就可以到网页，选择个人使用，接 …</content:encoded></item><item><title>pickle反序列化</title><link>https://baozongwi.xyz/p/pickle-deserialization/</link><guid>https://baozongwi.xyz/p/pickle-deserialization/</guid><pubDate>Fri, 28 Feb 2025 14:01:23 +0000</pubDate><description>pickle吗</description><content:encoded>说在前面 我很早就接触到了这个部分，或者说，距离今日，已经是好几个月了，但是我发现基本市面上的CTF比赛只会考察一点黑名单和reduce方法，所以我对这部分知识就没有那么的热情，现在不知道干嘛，就来学习下
question 开胃的方法 __reduce__ 我做过部分简单的题目，基本都是reduce …</content:encoded></item><item><title>JavaScript原型链污染</title><link>https://baozongwi.xyz/p/javascript-prototype-pollution/</link><guid>https://baozongwi.xyz/p/javascript-prototype-pollution/</guid><pubDate>Fri, 31 Jan 2025 19:25:47 +0000</pubDate><description>pollution_start!</description><content:encoded>0x01 前面很早就知道有这个姿势，但是一直拖欠，包括打ctfshow的时候也是一把锁，后面学了flask的原型链污染觉得很有意思，来学习一下，把坑填了
0x02 prototype&amp;amp;amp;amp;&amp;amp;amp;amp;__proto__ 零基础没关系，我们只要知道属性这个东西就可以，最简单的demo
1 2 3 4 …</content:encoded></item><item><title>Xdebug配置</title><link>https://baozongwi.xyz/p/xdebug-configuration/</link><guid>https://baozongwi.xyz/p/xdebug-configuration/</guid><pubDate>Thu, 05 Dec 2024 12:18:08 +0000</pubDate><description>debug，世界之钥</description><content:encoded>0x01 随着问题逐渐变复杂，发现debug才是世界硬通货，而刚好可以写一个，毕竟折磨了自己很久
0x02 首先这里是VSCODE+小皮+xdebug
vscode 首先这里先安装小皮一路战到底即可
小皮进去选择64位的就可以了，看了一下使用说明唯一的就是说不能使用有空格路径或者是中文路径，这里选择 …</content:encoded></item><item><title>hexo&amp;&amp;hugo搭建个人博客</title><link>https://baozongwi.xyz/p/hexo-hugo-personal-blog-setup/</link><guid>https://baozongwi.xyz/p/hexo-hugo-personal-blog-setup/</guid><pubDate>Tue, 03 Dec 2024 12:23:54 +0000</pubDate><description>0x01 说在前面 蒙上完学长课堂之后，有学弟询问怎么搭建个人博客，hexo我网上网友，线下的一些问题，说起来也有四五个了，所以非常顺手，同时我看到有挺多师傅是用的hugo的框架，那个FixIt主题也是非常好看所以顺手来看看
0x02 首先注册github
注册好了之后应该是这样子的
嗯那么我们首先来看hexo博客怎么搭建吧
hexo 初始化必要的东西 对于初学者的博客记录学习过程其实不需要知道每个东西是什么，因为我们只是用这个来记载，而不是说我们要自己写一个，所以说搭建博客没那么难，当一个脚本小子就可以了
安装nodejs和git
nodejs
git
nodejs最好是安装好TLS也就是长期智齿版本，那么到了一个不懂环境变量的小盆友最难受的时候了，也就是如何把这两个搞到环境变量里面去，首先我们到桌面有个搜索框
搜索系统环境变量一般的名称应该是编辑系统环境变量，不一样的话也是点小差异，无伤大雅
1 环境变量-&amp;amp;gt;Path(系统变量里面的)-&amp;amp;gt;编辑环境变量-&amp;amp;gt;新建 新建之后放文件路径这里
1 2 C:\Program Files\Git\cmd C:\Program Files\nodejs\ 可能路径稍微有不同，但是后面的一样就行也就是说只要是
1 2 nodejs\ Git\cmd 即可，然后win+r打开cmd进行检查
1 2 3 node version git version npm -v # (nodejs自带的) 本地初始化 然后我们下载hexo直接在终端中运行命令
1 npm install hexo-cli -g 然后在本地新建一个文件夹，这里选择一个大一点的盘，最少要有100G，固态硬盘最好，因为你的博客可能能坚持很久，也有可能开了一年就不开了，哈哈先想好的结果吧
文件名你要记得住，然后进入这个文件夹，鼠标右键选择Open Git bash here，我这里截图截不下来，win10应该是直接有，win11要选择更多选项，我为啥这么熟悉呢，因为我起码搭建了四五个hexo了
1 hexo init 这里可能会失败比如说下载不全等等原因，因为使用的git不过多试几次就好了，后面有师傅提供了一个比较方便的方法，容易成功就是在初始化的前面加上npx，不过相应的后面所有命令都要这样了并不是那么的方便</description><content:encoded>0x01 说在前面 蒙上完学长课堂之后，有学弟询问怎么搭建个人博客，hexo我网上网友，线下的一些问题，说起来也有四五个了，所以非常顺手，同时我看到有挺多师傅是用的hugo的框架，那个FixIt主题也是非常好看所以顺手来看看
0x02 首先注册github
注册好了之后应该是这样子的
嗯那么我们首先 …</content:encoded></item><item><title>waline评论设置一条龙</title><link>https://baozongwi.xyz/p/waline-comment-setup-guide/</link><guid>https://baozongwi.xyz/p/waline-comment-setup-guide/</guid><pubDate>Sat, 09 Nov 2024 19:50:46 +0000</pubDate><description>来评论区开黑</description><content:encoded>0x01 说在前面 博客的意义或许就是交流技术？但是没有评论区的话，总感觉我的博客不是完整的，不过这个问题我前前后后弄了一个月之久，为了让后人省省力，也为我自己记录一下，出个教程吧(虽然可能不是每个博客框架或者主题都是一模一样，但是肯定能够作为参考
0x02 action 初始化 首先我们去国际版本 …</content:encoded></item><item><title>github-pages自定义域名及加速</title><link>https://baozongwi.xyz/p/github-pages-custom-domain-acceleration/</link><guid>https://baozongwi.xyz/p/github-pages-custom-domain-acceleration/</guid><pubDate>Fri, 08 Nov 2024 11:42:44 +0000</pubDate><description>0x01 说在前面 起因是我这三个月爆肝了一百篇文章(个人认为不是都是水文，有师傅和我交流技术
我本身的博客是这样的(双保险)
首先部署到github上面然后再利用DK盾赞助的服务器进行转载，当然这样子即使服务器挂了也能用，而且也是进行了自然存档的(当然为了数据遗失，我在U盘上面存了我的blog文件夹)，毕竟都是我的心血
这样算下来过不了多久可能就会满，今天在群里面提了一嘴，Y爹和生蚝师傅都说githubpages也能满？
诶那我确实是可以直接打一个重定向，同时我还可以省一台服务器出来
0x02 action 自定义域名 这个其实真的很简单，我们就直接解析，然后写个文件就可以了
这里先去腾讯云解析，我是直接用的CNAME当然A也可以就是比较麻烦(注册域名就不说了，给钱就行)
1 https://myssl.com/dns_check.html 可以来这个网站查询一下，然后上github搞一下
就这样还不行，我之前以为就这样就可以了，但是发现只要一更新部署这里的东西就会不见，经过查询知道是说需要在本地的source文件夹里面创建一个文件
这样子就可以了，可以自己试试，不过我们信安人都是一直有魔法，如果没有魔法的话，这个网站就会很卡，那么下一步
加速 但是我发现国内加速都要备案才可以，备案真的很麻烦而且我也很难操作，那只能用CF了虽然是慢了点
1 https://dash.cloudflare.com/ 然后找到解析记录去换一下
1 https://console.cloud.tencent.com/domain/all-domain/all 修改成CF给的就可以了，不过我看了一下，还是有部分被墙的，不过已经很好了，至少不会像github.io一样，连有些图标都显示不出来(毕竟不要钱)
0x03 小结 或许后面有钱会换CDN，但是暂时用这个，而且过程都差不多的，不用担心vps的内存问题了哈哈哈 谢谢生蚝和Y爹</description><content:encoded>0x01 说在前面 起因是我这三个月爆肝了一百篇文章(个人认为不是都是水文，有师傅和我交流技术
我本身的博客是这样的(双保险)
首先部署到github上面然后再利用DK盾赞助的服务器进行转载，当然这样子即使服务器挂了也能用，而且也是进行了自然存档的(当然为了数据遗失，我在U盘上面存了我的blog文件 …</content:encoded></item><item><title>php中不出网的FFI</title><link>https://baozongwi.xyz/p/php-non-outbound-ffi/</link><guid>https://baozongwi.xyz/p/php-non-outbound-ffi/</guid><pubDate>Fri, 08 Nov 2024 09:27:18 +0000</pubDate><description>0x01 前言 我知道这个姿势是在暑假的8月份好像是极客大挑战的RCE5？，一直耽搁着到现在来看看
0x02 question 了解 当PHP7.4降临，与他一同前来的还有一个强大拓展PHP FFI
它允许PHP代码调用C语言库中的函数，而无需编写和编译传统的PHP扩展。通过FFI，开发者可以直接在PHP中编写与C库的接口（bindings），而不必使用C语言编写扩展。这极大地简化了扩展PHP功能的过程，并使其更灵活。
For PHP, FFI opens a way to write PHP extensions and bindings to C libraries in pure PHP.
加载C库：可以通过FFI直接加载共享库（如.so或.dll文件）。 定义C函数和类型：在PHP中以字符串的形式定义C语言的函数、结构体、类型等。 调用C函数：一旦定义了C函数，就可以像调用PHP函数一样在PHP中调用它们 FFI::cdef 看不懂啊，那我们看demo，以师傅的例子来讲，我们用PHP的curl，和libcurl来进行对比
首先我们修改ini文件
1 2 extension=ffi ffi.enable=true 然后写demo就发现有很多问题，比如说找不到什么的，然后查了查，只有Linux才行
接下来放出源码
1 2 3 4 5 6 7 8 9 10 11 &amp;amp;lt;?php $url = &amp;amp;#34;https://www.laruence.com/2020/03/11/5475.html&amp;amp;#34;; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); curl_exec($ch); curl_close($ch); 这是不使用FFI的情况</description><content:encoded>0x01 前言 我知道这个姿势是在暑假的8月份好像是极客大挑战的RCE5？，一直耽搁着到现在来看看
0x02 question 了解 当PHP7.4降临，与他一同前来的还有一个强大拓展PHP FFI
它允许PHP代码调用C语言库中的函数，而无需编写和编译传统的PHP扩展。通过FFI，开发者可以直接 …</content:encoded></item><item><title>powershell链接vps</title><link>https://baozongwi.xyz/p/powershell-vps-connection/</link><guid>https://baozongwi.xyz/p/powershell-vps-connection/</guid><pubDate>Mon, 04 Nov 2024 15:52:58 +0000</pubDate><description>丝滑</description><content:encoded>0x01 前言 看到朋友上个月的终端非常好看，那么我也要，意外是没想到这个东西还这么丝滑
0x02 action 安装&amp;amp;amp;amp;&amp;amp;amp;amp;美化 下载terminal
1 https://github.com/microsoft/terminal/releases/tag/v1.21.2911.0 下 …</content:encoded></item><item><title>markdown常用语法</title><link>https://baozongwi.xyz/p/markdown-common-syntax/</link><guid>https://baozongwi.xyz/p/markdown-common-syntax/</guid><pubDate>Mon, 28 Oct 2024 21:15:30 +0000</pubDate><description>写md最开始看的文章</description><content:encoded>0x01 前言 程序员都用的做笔记的语法，也是非常实用了，下面我只提及好用并且经常用的
0x02 action 常用的 首先就是标题，使用#
1 2 3 4 # 一级标题 ## 二级标题 ### 三级标题 总共最多是六级标题 加粗，Ctrl+B
代码的包裹，使用反引号
1 `baozongwi` 代 …</content:encoded></item><item><title>flask中的session伪造</title><link>https://baozongwi.xyz/p/flask-session-forgery/</link><guid>https://baozongwi.xyz/p/flask-session-forgery/</guid><pubDate>Tue, 22 Oct 2024 15:30:50 +0000</pubDate><description>0x01 说在前面 在一般的情况下，网站都会做一个简答的身份验证，而flask当中自然也有，这种就是我们常见的session，session是什么，可以看这个文章
1 https://baozongwi.xyz/2024/09/11/%E6%B5%85%E8%B0%88session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ 0x02 question 现在网上进行session伪造的很少有不需要key的几乎没有，所以这里推荐一个工具叫做flask-unsign，还有就是大家经常使用的脚本，不过我们先看一下结构
结构 先随便生成一个session
1 eyJsb2NhbGUiOiJlbiJ9-ZSDIwA-v5-mHM9ITAx5lbFhwa3jNnWTIYY Flask Session 的组成结构主要由三部分构成，第一部分为 Session Data ，即会话数据。第二部分为 Timestamp ，即时间戳。第三部分为 Cryptographic Hash ，即加密哈希。如下图
下面的结果是看P牛的博客知道的(他有代码)
json.dumps 将对象转换成json字符串，作为数据 如果数据压缩后长度更短，则用zlib库进行压缩 将数据用base64编码 通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割 签名只能防篡改不能防止被读取，所以我们只要有key就可以伪造cookie
解密代码 我们上面已经知道了逻辑，那么来分析一个脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env python3 import sys import zlib from base64 import b64decode from flask.sessions import session_json_serializer from itsdangerous import base64_decode def decryption(payload): payload, sig = payload.rsplit(b&amp;amp;#39;.&amp;amp;#39;, 1) payload, timestamp = payload.rsplit(b&amp;amp;#39;.&amp;amp;#39;, 1) decompress = False if payload.startswith(b&amp;amp;#39;.&amp;amp;#39;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&amp;amp;#39;Could not base64 decode the payload because of &amp;amp;#39; &amp;amp;#39;an exception&amp;amp;#39;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&amp;amp;#39;Could not zlib decompress the payload before &amp;amp;#39; &amp;amp;#39;decoding the payload&amp;amp;#39;) return session_json_serializer.loads(payload) if __name__ == &amp;amp;#39;__main__&amp;amp;#39;: print(decryption(&amp;amp;#34;eyJ1c2VybmFtZSI6eyIgYiI6IlozVmxjM1E9In19.XyZ3Vw.OcD3-l1yOcq8vlg8g4Ww3FxrhVs&amp;amp;#34;.encode())) 一步步来首先，用.给session分开，然后看看是否是压缩过的</description><content:encoded>0x01 说在前面 在一般的情况下，网站都会做一个简答的身份验证，而flask当中自然也有，这种就是我们常见的session，session是什么，可以看这个文章
1 …</content:encoded></item><item><title>phar反序列化bypass</title><link>https://baozongwi.xyz/p/phar-deserialization-bypass/</link><guid>https://baozongwi.xyz/p/phar-deserialization-bypass/</guid><pubDate>Sat, 12 Oct 2024 21:28:14 +0000</pubDate><description>0x01 前言 前面学习phar反序列化的时候我就看到有一些绕过姿势，但是感觉太多了，于是想着单写一篇
0x02 question 文件头 修改stub，在其中加入图片头即可
1 $phar-&amp;amp;gt;setStub(&amp;amp;#34;GIF89a&amp;amp;lt;?php __HALT_COMPILER();?&amp;amp;gt;&amp;amp;#34;); 协议 1 2 1、使用filter伪协议来进行绕过 php://filter/read=convert.base64-encode/resource=phar://phar.phar/m.php 1 2 3 4 5 6 7 8 9 10 11 12 13 &amp;amp;lt;?php class Hello{ public $name=&amp;amp;#39;bao&amp;amp;#39;; } @unlink(&amp;amp;#34;phar.phar&amp;amp;#34;); $phar=new Phar(&amp;amp;#34;phar.phar&amp;amp;#34;); $phar-&amp;amp;gt;startBuffering(); //开缓冲 $phar-&amp;amp;gt;setStub(&amp;amp;#34;GIF89a&amp;amp;lt;?php __HALT_COMPILER();?&amp;amp;gt;&amp;amp;#34;); $o=new Hello(); $phar-&amp;amp;gt;setMetadata($o); $phar-&amp;amp;gt;addFromString(&amp;amp;#34;m.php&amp;amp;#34;,&amp;amp;#34;&amp;amp;lt;?php system(&amp;amp;#39;dir&amp;amp;#39;); ?&amp;amp;gt;&amp;amp;#34;); //写入m.php $phar-&amp;amp;gt;stopBuffering(); //关缓冲 ?&amp;amp;gt; 1 2 &amp;amp;lt;?php include(&amp;amp;#39;php://filter/read=convert.base64-encode/resource=phar://phar.phar/m.php&amp;amp;#39;); 2、使用bzip2协议来进行绕过
这里还是正常生成一个phar文件，只不过要进行处理一下
1 2 3 bzip2 -k phar.phar compress.bzip2://phar://phar.phar/m.php 3、使用zlib协议进行绕过</description><content:encoded>0x01 前言 前面学习phar反序列化的时候我就看到有一些绕过姿势，但是感觉太多了，于是想着单写一篇
0x02 question 文件头 修改stub，在其中加入图片头即可
1 $phar-&amp;amp;amp;gt;setStub(&amp;amp;amp;#34;GIF89a&amp;amp;amp;lt;?php …</content:encoded></item><item><title>flask原型链污染</title><link>https://baozongwi.xyz/p/flask-prototype-pollution/</link><guid>https://baozongwi.xyz/p/flask-prototype-pollution/</guid><pubDate>Thu, 03 Oct 2024 16:57:12 +0000</pubDate><description>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的所有属性和方法，还可以添加新的属性和方法，或者重写父类的方法。
同时还有几个重要方法，这里直接引用一位师傅所写的
在Python中，定义类是通过class关键字，class后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的，所有类的本源都是object类 可以自由地给一个实例变量绑定属性，像js 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把类内置的属性绑上 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到 判断一个变量是否是某个类型可以用isinstance()判断。 普通继承 在子类中，你可以使用 super() 函数来调用父类的方法。这在子类需要扩展而不是完全重写父类方法时特别有用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Animal: def __init__(self, name): self.name = name def speak(self): raise NotImplementedError(&amp;amp;#34;Subclass must implement this abstract method&amp;amp;#34;) def eat(self): print(f&amp;amp;#34;{self.name} is eating.&amp;amp;#34;) class Dog(Animal): def __init__(self, name, breed): super().__init__(name) # 调用父类的构造函数 self.breed = breed def speak(self): print(f&amp;amp;#34;{self.name} says Woof!&amp;amp;#34;) def fetch(self): print(f&amp;amp;#34;{self.name} is fetching the ball.&amp;amp;#34;) class Cat(Animal): def __init__(self, name, color): super().__init__(name) # 调用父类的构造函数 self.color = color def speak(self): super().speak() # 调用父类的 speak 方法 print(f&amp;amp;#34;{self.name} says Meow!&amp;amp;#34;) def scratch(self): print(f&amp;amp;#34;{self.name} is scratching the furniture.&amp;amp;#34;) instance = Cat(&amp;amp;#34;无情&amp;amp;#34;,&amp;amp;#34;black&amp;amp;#34;) print(instance.name) 看看就行感觉没啥好讲的，看就能看懂</description><content:encoded>0x01 前言 baseCTF里面的那几道我都是现学现做，只是知道污染怎么操作，并不知道为啥可以污染，这次让我彻底弄懂它！
0x02 question 父子类的继承 概念 父类是被继承的类，也称为基类或超类。父类中的属性和方法会被子类继承。
子类是从父类继承而来的类，也称为派生类。子类可以拥有父类的 …</content:encoded></item><item><title>session文件包含</title><link>https://baozongwi.xyz/p/session-file-inclusion/</link><guid>https://baozongwi.xyz/p/session-file-inclusion/</guid><pubDate>Fri, 27 Sep 2024 13:39:03 +0000</pubDate><description>经典</description><content:encoded>0x01 前言 之前觉得很难的姿势，现在学习了一下，感觉还行啊，果然多多尝试才有结果
0x02 question 这个的大部分基础知识都在session反序列化提到了，所以这里就将session文件包含所需要的，当涉及session的时候，我们可以利用ID来保留属于自己的信息
那么我们如果上传文件进 …</content:encoded></item><item><title>深入浅出XSS</title><link>https://baozongwi.xyz/p/xss-in-depth/</link><guid>https://baozongwi.xyz/p/xss-in-depth/</guid><pubDate>Wed, 25 Sep 2024 08:04:23 +0000</pubDate><description>0x01 前言 最近发现xss的利用还是挺多的，但是自己又处于一个只会用低级payload的水平,所以来学习一下
0x02 question what‘s this 原理 原理就是很简单，类似于注入，我们插入了恶意代码在网页中，并且也被成功解析了
利用场景 浏览器可以执行JavaScript代码（这不是废话吗）。 网页可以显示用户输入的内容。包括但不限于：根据url中的参数渲染网页、预览输入框写好的内容、留言板等其他用户提交的内容等。 那么很显然这是被动的攻击，在之前并不流行，但是现在互联网主要讲求一个&amp;amp;quot;互&amp;amp;quot;,所以自然而然的也可以进行利用了，而能来干什么(最常见的钓鱼)
干啥 窃取cookie或token来获得用户登录态； 劫持流量，把用户正在访问的页面跳转到钓鱼网站； 盗用账户来转账、群发信息等； 利用用户的设备来发起DDOS攻击； demo 这次我们从一个最简单的demo来看看原理
1 2 3 &amp;amp;lt;?php $xss=$_GET[&amp;amp;#39;id&amp;amp;#39;]; echo $xss; 1 ?id=&amp;amp;lt;script&amp;amp;gt;alert(1)&amp;amp;lt;/script&amp;amp;gt; 直接就出现弹窗了，也就是因为我们的恶意代码被解析插入，这样子看其实还是不是很能理解，再来个demo，这个demo也就花了我两个小时吧，艹想哭了
为了更加直观的看到为什么会造成xss，我零基础学了如果使用Tomcat来搭建一个本地服务，其中载入jsp漏洞代码，即可进行xss测试
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &amp;amp;lt;%@ page language=&amp;amp;#34;java&amp;amp;#34; contentType=&amp;amp;#34;text/html; charset=UTF-8&amp;amp;#34; pageEncoding=&amp;amp;#34;UTF-8&amp;amp;#34;%&amp;amp;gt; &amp;amp;lt;!DOCTYPE html&amp;amp;gt; &amp;amp;lt;html lang=&amp;amp;#34;zh-CN&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;head&amp;amp;gt; &amp;amp;lt;meta charset=&amp;amp;#34;UTF-8&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;meta name=&amp;amp;#34;viewport&amp;amp;#34; content=&amp;amp;#34;width=device-width, initial-scale=1.0&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title&amp;amp;gt;XSS 测试页面&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;/head&amp;amp;gt; &amp;amp;lt;body&amp;amp;gt; &amp;amp;lt;h1&amp;amp;gt;XSS 测试页面&amp;amp;lt;/h1&amp;amp;gt; &amp;amp;lt;form action=&amp;amp;#34;xss_test.jsp&amp;amp;#34; method=&amp;amp;#34;get&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;label for=&amp;amp;#34;message&amp;amp;#34;&amp;amp;gt;输入消息:&amp;amp;lt;/label&amp;amp;gt; &amp;amp;lt;input type=&amp;amp;#34;text&amp;amp;#34; id=&amp;amp;#34;message&amp;amp;#34; name=&amp;amp;#34;message&amp;amp;#34; value=&amp;amp;#34;&amp;amp;lt;%= request.getParameter(&amp;amp;#34;message&amp;amp;#34;) == null ? &amp;amp;#34;&amp;amp;#34; : request.getParameter(&amp;amp;#34;message&amp;amp;#34;) %&amp;amp;gt;&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;button type=&amp;amp;#34;submit&amp;amp;#34;&amp;amp;gt;提交&amp;amp;lt;/button&amp;amp;gt; &amp;amp;lt;/form&amp;amp;gt; &amp;amp;lt;div&amp;amp;gt; 您输入的消息是：&amp;amp;lt;%= request.getParameter(&amp;amp;#34;message&amp;amp;#34;) == null ? &amp;amp;#34;null&amp;amp;#34; : request.getParameter(&amp;amp;#34;message&amp;amp;#34;) %&amp;amp;gt; &amp;amp;lt;/div&amp;amp;gt; &amp;amp;lt;/body&amp;amp;gt; &amp;amp;lt;/html&amp;amp;gt; 先简单的写个xss_test.jsp直接用来测试的</description><content:encoded>0x01 前言 最近发现xss的利用还是挺多的，但是自己又处于一个只会用低级payload的水平,所以来学习一下
0x02 question what‘s this 原理 原理就是很简单，类似于注入，我们插入了恶意代码在网页中，并且也被成功解析了
利用场景 浏览器可以执行JavaScript代码（这 …</content:encoded></item><item><title>php原生类的利用</title><link>https://baozongwi.xyz/p/php-native-class-exploitation/</link><guid>https://baozongwi.xyz/p/php-native-class-exploitation/</guid><pubDate>Thu, 19 Sep 2024 10:09:04 +0000</pubDate><description>0x01 前言 在base和其他部分赛题中遇到了几道原生类的利用刚好，我在计划中也有此打算进行学习以及利用，那么就来看看吧
0x02 question 了解原生类 PHP 作为一门广泛应用于 Web 开发的脚本语言，它的目标是帮助开发者快速构建功能丰富的应用程序。因此，它提供了大量的原生类和函数，通过这些类的调用，PHP 开发者可以轻松处理文件、数据库、网络请求、加密等多种任务，极大地提升了开发效率。
所以说其实是有很多原生类的，包括算法\压缩\json\xml\图像等等，很多，大家可以自己去深入研究，这里的话只提及我们平时能够进行利用，达到任意文件读取\ssrf等攻击手段的原生类
原生类的利用 反射 ReflectionMethod 利用版本：(PHP 5, PHP 7)
ReflectionMethod 是 PHP 提供的反射类之一，用于获取类中某个具体方法的详细信息。
常见方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # 反射调用方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;invoke(new [class?]/NULL(静态类),args1,args2); (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;invokeArgs(new [class?]/NULL(静态类,[args1,args2])); # 设置私有/受保护方法 $f = new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;); $f-&amp;amp;gt;setAccessible(true); $f-&amp;amp;gt;invoke(new [class?]); (new [class?])-&amp;amp;gt;[method?](); // 会报错 # 获取函数信息 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getDeclaringClass() // 获取反射方法的类作为反射类返回 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isAbstract() // 方法是否是抽象方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isConstructor() // 方法是否是 __construct (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isDestructor() // 方法是否是 __destruct (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isFinal() // 方法是否定义了final (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isPrivate() // 方法是否是私有方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isProtected() // 方法是否是受保护方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isPublic() // 方法是否是公有方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isStatic() // 方法是否是静态方法 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getDocComment() // 获取方法注释内容 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getStartLine() // 获取方法开始行号 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getEndLine() // 获取方法结束行号 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getExtensionName() // 获取扩展名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getName() // 获取方法名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNamespaceName() // 获取命名空间名称 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNumberOfParameters() // 获取方法参数数量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getNumberOfRequiredParameters() // 获取方法必须传入的参数数量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getParameters() // 获取方法参数名 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getShortName() // 获取方法短名 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;getStaticVariables() // 获取方法静态变量 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;hasReturnType() // 方法是否有特定返回类型 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;inNamespace() // 方法是否定义在命名空间 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isClosure() // 方法是否是匿名函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isDeprecated() // 方法是否弃用 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isGenerator() // 方法是否是生成器函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isInternal() // 方法是否是内部函数 (new ReflectionMethod(&amp;amp;#34;class?&amp;amp;#34;,&amp;amp;#34;method?&amp;amp;#34;))-&amp;amp;gt;isUserDefined() // 方法是否是用户定义 [2021 CISCN]easy_source</description><content:encoded>0x01 前言 在base和其他部分赛题中遇到了几道原生类的利用刚好，我在计划中也有此打算进行学习以及利用，那么就来看看吧
0x02 question 了解原生类 PHP 作为一门广泛应用于 Web 开发的脚本语言，它的目标是帮助开发者快速构建功能丰富的应用程序。因此，它提供了大量的原生类和函数，通 …</content:encoded></item><item><title>深入浅出xxe</title><link>https://baozongwi.xyz/p/xxe-in-depth/</link><guid>https://baozongwi.xyz/p/xxe-in-depth/</guid><pubDate>Wed, 18 Sep 2024 11:52:15 +0000</pubDate><description>0x01 前言 前两天看了一下xxe的题目，感觉也可以来补补这个基础知识来，为了这个，还浅浅的了解了一下伪协议
0x02 question xml了解 XML（Extensible Markup Language，可扩展标记语言）是一种用于存储和传输数据的标记语言，它类似于 HTML，但更加灵活，主要用于定义数据，而不是显示数据。XML 的设计目标是数据的可移植性、可读性以及易于扩展。也就是和序列化差不多的特点(但是不能混为一谈哦)
XML 文档的结构通常由三部分组成：XML 声明、**DTD(可选的文档类型定义) **和 **元素(内容部分) **。
写一个xml的demo来分析这三个结构
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &amp;amp;lt;?xml version=&amp;amp;#34;1.0&amp;amp;#34; encoding=&amp;amp;#34;UTF-8&amp;amp;#34;?&amp;amp;gt; &amp;amp;lt;!DOCTYPE bookstore SYSTEM &amp;amp;#34;bookstore.dtd&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;bookstore&amp;amp;gt; &amp;amp;lt;book category=&amp;amp;#34;fiction&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title lang=&amp;amp;#34;en&amp;amp;#34;&amp;amp;gt;The Great Gatsby&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;author&amp;amp;gt;F. Scott Fitzgerald&amp;amp;lt;/author&amp;amp;gt; &amp;amp;lt;year&amp;amp;gt;1925&amp;amp;lt;/year&amp;amp;gt; &amp;amp;lt;price&amp;amp;gt;10.99&amp;amp;lt;/price&amp;amp;gt; &amp;amp;lt;/book&amp;amp;gt; &amp;amp;lt;book category=&amp;amp;#34;non-fiction&amp;amp;#34;&amp;amp;gt; &amp;amp;lt;title lang=&amp;amp;#34;en&amp;amp;#34;&amp;amp;gt;Sapiens: A Brief History of Humankind&amp;amp;lt;/title&amp;amp;gt; &amp;amp;lt;author&amp;amp;gt;Yuval Noah Harari&amp;amp;lt;/author&amp;amp;gt; &amp;amp;lt;year&amp;amp;gt;2011&amp;amp;lt;/year&amp;amp;gt; &amp;amp;lt;price&amp;amp;gt;14.99&amp;amp;lt;/price&amp;amp;gt; &amp;amp;lt;/book&amp;amp;gt; &amp;amp;lt;/bookstore&amp;amp;gt; xml声明 这个东西就类似于，使用C语言编程的</description><content:encoded>0x01 前言 前两天看了一下xxe的题目，感觉也可以来补补这个基础知识来，为了这个，还浅浅的了解了一下伪协议
0x02 question xml了解 XML（Extensible Markup Language，可扩展标记语言）是一种用于存储和传输数据的标记语言，它类似于 HTML，但更加灵活，主 …</content:encoded></item><item><title>php伪协议</title><link>https://baozongwi.xyz/p/php-pseudo-protocols/</link><guid>https://baozongwi.xyz/p/php-pseudo-protocols/</guid><pubDate>Mon, 16 Sep 2024 09:31:51 +0000</pubDate><description>0x01 前言 本来是想看看xxe的，但是发现其中使用协议非常的频繁，刚好我协议也没有总结过，那么来弄完这个弄xxe
0x02 question 概念 数据流 PHP伪协议是一种用于处理各种文件流和资源的机制。通过伪协议，PHP可以访问各种数据源（不仅限于文件），并执行特定任务。这些伪协议常用于文件系统操作、数据流处理以及与网络和数据库的交互。
那么既然提到了是数据流，让我想起来之前有一位师傅问我的问题
1 2 &amp;amp;lt;?php file_put_contents(&amp;amp;#39;php://filter/w=convert.base64-decode/resource=shell.php&amp;amp;#39;,&amp;amp;#39;eHl6&amp;amp;#39;); 这里我们可以利用伪协议来代替文件，进行写入恶意代码，但是为什么呢
数据流的抽象：PHP 的文件处理函数（如 fopen、file_get_contents 等）能够操作的数据并不局限于硬盘上的文件，它们可以操作任意数据流。伪协议让这些函数通过统一的接口来处理各种数据源，比如网络数据、内存数据、压缩数据等等。也就是说我们的伪协议其实并不是文件，只不过在抽象的机制下，可以达到文件的效果，所以细心的师傅发现我们使用伪协议的路径并不是像物理文件一样使用绝对路径
伪协议 1 2 3 4 5 6 7 8 9 10 11 12 file:// — 访问本地文件系统 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流 php.ini 在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。
allow_url_fopen:默认值是ON。允许url里的封装协议访问文件； allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件； test demo.php
1 2 &amp;amp;lt;?php file_get_contents($_GET[&amp;amp;#39;a&amp;amp;#39;]); 写好Demo之后我们挨个把常用的测试一下
php://filter 这个协议应该是最常用的</description><content:encoded>0x01 前言 本来是想看看xxe的，但是发现其中使用协议非常的频繁，刚好我协议也没有总结过，那么来弄完这个弄xxe
0x02 question 概念 数据流 PHP伪协议是一种用于处理各种文件流和资源的机制。通过伪协议，PHP可以访问各种数据源（不仅限于文件），并执行特定任务。这些伪协议常用于文件 …</content:encoded></item><item><title>php GC回收机制以及常见利用利用方式</title><link>https://baozongwi.xyz/p/php-gc-mechanism-and-common-exploitation/</link><guid>https://baozongwi.xyz/p/php-gc-mechanism-and-common-exploitation/</guid><pubDate>Sat, 14 Sep 2024 18:58:51 +0000</pubDate><description>0x01 前言 之前总结了wakeup的绕过方法但是其中的两种姿势，其实都是和这个GC的回收机制有关系所以我来浅浅的解析一下，会自己的姿势库分析一下，嘿嘿
0x02 question GC是啥 PHP 的垃圾回收机制（Garbage Collection, GC）是用于管理内存分配的一个自动化过程，主要针对循环引用的内存泄漏问题。它是在 PHP 5.3 之后引入的增强功能，帮助开发者自动管理内存，尤其是在复杂的应用场景下。
那么它是根据什么来定位哪些可以回收的呢，引用计数和回收周期，这两个东西是啥啊？
引用计数 引用计数是一种内存管理技术，用来记录一个值或对象被多少个变量引用。每当一个变量指向某个值时，引用计数就会增加；当某个变量不再引用该值时，引用计数就会减少。当引用计数降为 0 时，表示没有变量再使用这个值，系统会将其占用的内存释放。
1 2 3 4 5 &amp;amp;lt;?php $a=&amp;amp;#34;baozongwi&amp;amp;#34;; xdebug_debug_zval(&amp;amp;#34;a&amp;amp;#34;); /* a: (refcount=1, is_ref=0)=&amp;amp;#39;baozongwi&amp;amp;#39; 看到这段代码，怎么来的，来分析一下
每个php变量存在一个叫zval的变量容器中。 一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。 这两个额外信息，第一个是is_ref，是个bool值，用来标识这个变量是否是属于引用集合。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;amp;amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。 第二个额外字节是 refcount，用以表示指向这个zval变量容器的变量个数。 所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。 那么开始测试
标量 1 2 3 4 5 6 7 &amp;amp;lt;?php $a = &amp;amp;#34;baozongwi&amp;amp;#34;; $b = $a; // $a 和 $b 引用相同的字符串，refcount 应为 2 xdebug_debug_zval(&amp;amp;#39;a&amp;amp;#39;); // 检查 $a 的 refcount /* a: (refcount=1, is_ref=0)=&amp;amp;#39;baozongwi&amp;amp;#39; 这里我们预期上其实应该是2的，因为变量个数所增加了，但是实际上为啥是1呢，通过查阅我发现，原来内部机制是这样
PHP 使用了一种称为 写时复制（Copy-on-Write, COW） 的内存优化机制，这意味着当你将 $a 的值赋给 $b 时，PHP 并不会立即复制该值，而是让 $b 和 $a 指向同一个内存块，直到其中一个变量被修改。</description><content:encoded>0x01 前言 之前总结了wakeup的绕过方法但是其中的两种姿势，其实都是和这个GC的回收机制有关系所以我来浅浅的解析一下，会自己的姿势库分析一下，嘿嘿
0x02 question GC是啥 PHP 的垃圾回收机制（Garbage Collection, GC）是用于管理内存分配的一个自动化过程， …</content:encoded></item><item><title>浅谈session反序列化</title><link>https://baozongwi.xyz/p/session-deserialization-discussion/</link><guid>https://baozongwi.xyz/p/session-deserialization-discussion/</guid><pubDate>Wed, 11 Sep 2024 16:15:57 +0000</pubDate><description>session反序列化</description><content:encoded>0x01 前言 这几天好多奇怪的事情，让我不得不放下一些东西，哎哟，把这个session反序列化拿下就去看GC回收机制
0x02 question 概念 session 本身机制 session（会话）是服务器端用于在用户访问网站时保存信息的一种机制。它允许在多个页面请求之间共享和持久化数据，以便追 …</content:encoded></item><item><title>php反序列化\pop</title><link>https://baozongwi.xyz/p/php-deserialization-pop/</link><guid>https://baozongwi.xyz/p/php-deserialization-pop/</guid><pubDate>Sat, 07 Sep 2024 11:03:57 +0000</pubDate><description>pop入门</description><content:encoded>0x01 前言 总感觉自己的php反序列化不够稳定，简单的那确实直接就秒了，稍微来点东西就卡着，所以我觉得还是很有必要来深入浅出一下
0x02 question 概念 什么是序列化?
serialize()：将变量序列化为字符串。
什么是反序列化?
unserialize()：将序列化后的字符串恢复 …</content:encoded></item><item><title>浅析phar反序列化</title><link>https://baozongwi.xyz/p/phar-deserialization-analysis/</link><guid>https://baozongwi.xyz/p/phar-deserialization-analysis/</guid><pubDate>Thu, 05 Sep 2024 19:28:03 +0000</pubDate><description>phar~</description><content:encoded>0x01 前言 之前在学习php反序列化的时候难免会遇到phar文件的反序列化来恶意载入马，但是始终难以理解这样的姿势，现在再去看，貌似也释然了，这个常用姿势，拿下(以后拿ezphp来骗我也不怕啦)
0x02 question 概念 PHAR 文件（PHP Archive）是一种用于将多个 PHP …</content:encoded></item><item><title>Ubuntu16.04配置pwn基础环境</title><link>https://baozongwi.xyz/p/ubuntu-1604-pwn-environment-setup/</link><guid>https://baozongwi.xyz/p/ubuntu-1604-pwn-environment-setup/</guid><pubDate>Tue, 03 Sep 2024 20:27:38 +0000</pubDate><description>pwn的环境总得有吧</description><content:encoded>0x01 前言 其实我觉得二进制这个东西还是比较神圣的,虽然我不会,但是我不能没有环境哇
0x02 action 16.04 安装VMtools，网上有教程，我的莫名其妙就好了
1 2 sudo apt update sudo apt install curl # 安装 curl 下载工具 1 2 …</content:encoded></item><item><title>浅析flask内存马</title><link>https://baozongwi.xyz/p/flask-memory-shell-analysis/</link><guid>https://baozongwi.xyz/p/flask-memory-shell-analysis/</guid><pubDate>Mon, 02 Sep 2024 11:03:56 +0000</pubDate><description>你学SSTI不学内存马？</description><content:encoded>0x01 前言 flask中的SSTI注入或许是个好姿势，但是我能不能getshell呢,之前经常阅读联队写的大赛WP,&amp;amp;amp;ldquo;写个脚本打入内存马&amp;amp;amp;rdquo;，好高级，好想学，那今天我来看看这到底是个什么乾坤
0x02 question flask现在已经更新换代了，但是我觉得仍然值得学习， …</content:encoded></item><item><title>浅析flask中的SSTI漏洞</title><link>https://baozongwi.xyz/p/flask-ssti-vulnerability-analysis/</link><guid>https://baozongwi.xyz/p/flask-ssti-vulnerability-analysis/</guid><pubDate>Sun, 01 Sep 2024 09:51:44 +0000</pubDate><description>SSTI吗</description><content:encoded>0x01 前言 或许这里说成是flask并不妥当，因为仅仅只是讲解了jinja这种常用的SSti漏洞,但是其实payload都是大同小异，那就这样吧
0x02 question 概念 SSTI（Server-Side Template Injection，服务器端模板注入）漏洞是一种网络安全漏洞，发 …</content:encoded></item><item><title>ysoserial配置</title><link>https://baozongwi.xyz/p/ysoserial-configuration/</link><guid>https://baozongwi.xyz/p/ysoserial-configuration/</guid><pubDate>Mon, 19 Aug 2024 21:06:28 +0000</pubDate><description>安装 配置 直接将整个项目拖进来就会显示配置为mov项目
如果没有显示的话可以自己右键pom.xml进行mov项目解析
再者进行项目的忽略
我这里是已经忽略了然后打开，选择进行clean
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 &amp;amp;#34;C:\Program Files\Java\jdk1.8.0_201\bin\java.exe&amp;amp;#34; -Dmaven.multiModuleProjectDirectory=C:\Users\baozhongqi\Desktop\ysoserial-master\ysoserial-master -Djansi.passthrough=true &amp;amp;#34;-Dmaven.home=D:\IntelliJ IDEA 2024.2.0.1\plugins\maven\lib\maven3&amp;amp;#34; &amp;amp;#34;-Dclassworlds.conf=D:\IntelliJ IDEA 2024.2.0.1\plugins\maven\lib\maven3\bin\m2.conf&amp;amp;#34; &amp;amp;#34;-Dmaven.ext.class.path=D:\IntelliJ IDEA 2024.2.0.1\plugins\maven\lib\maven-event-listener.jar&amp;amp;#34; &amp;amp;#34;-javaagent:D:\IntelliJ IDEA 2024.2.0.1\lib\idea_rt.jar=63881:D:\IntelliJ IDEA 2024.2.0.1\bin&amp;amp;#34; -Dfile.encoding=UTF-8 -classpath &amp;amp;#34;D:\IntelliJ IDEA 2024.2.0.1\plugins\maven\lib\maven3\boot\plexus-classworlds-2.8.0.jar;D:\IntelliJ IDEA 2024.2.0.1\plugins\maven\lib\maven3\boot\plexus-classworlds.license&amp;amp;#34; org.codehaus.classworlds.Launcher -Didea.version=2024.2.0.1 clean [INFO] Scanning for projects... [INFO] [INFO] ------------------------&amp;amp;lt; ysoserial:ysoserial &amp;amp;gt;------------------------- [INFO] Building ysoserial 0.0.6-SNAPSHOT [INFO] from pom.xml [INFO] --------------------------------[ jar ]--------------------------------- Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/3.2.0/maven-clean-plugin-3.2.0.pom Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/3.2.0/maven-clean-plugin-3.2.0.pom (5.3 kB at 2.8 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-plugins/35/maven-plugins-35.pom Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-plugins/35/maven-plugins-35.pom (9.9 kB at 7.3 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/maven-parent/35/maven-parent-35.pom Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/maven-parent/35/maven-parent-35.pom (45 kB at 15 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/apache/apache/25/apache-25.pom Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/apache/25/apache-25.pom (21 kB at 13 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/3.2.0/maven-clean-plugin-3.2.0.jar Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/3.2.0/maven-clean-plugin-3.2.0.jar (36 kB at 19 kB/s) [INFO] [INFO] --- clean:3.2.0:clean (default-clean) @ ysoserial --- Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-shared-utils/3.3.4/maven-shared-utils-3.3.4.pom Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-shared-utils/3.3.4/maven-shared-utils-3.3.4.pom (5.8 kB at 9.3 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-shared-components/34/maven-shared-components-34.pom Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-shared-components/34/maven-shared-components-34.pom (5.1 kB at 3.4 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/maven-parent/34/maven-parent-34.pom Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/maven-parent/34/maven-parent-34.pom (43 kB at 13 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-shared-utils/3.3.4/maven-shared-utils-3.3.4.jar Downloaded from central: https://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-shared-utils/3.3.4/maven-shared-utils-3.3.4.jar (153 kB at 22 kB/s) Downloading from central: https://repo.maven.apache.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar Downloaded from central: https://repo.maven.apache.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar (215 kB at 22 kB/s) [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 33.033 s [INFO] Finished at: 2024-08-19T21:12:09+08:00 [INFO] ------------------------------------------------------------------------ 进程已结束，退出代码为 0 终端这样子就是成功clean了</description><content:encoded>安装 配置 直接将整个项目拖进来就会显示配置为mov项目
如果没有显示的话可以自己右键pom.xml进行mov项目解析
再者进行项目的忽略
我这里是已经忽略了然后打开，选择进行clean
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 …</content:encoded></item><item><title>flask计算pin值</title><link>https://baozongwi.xyz/p/flask-pin-calculation/</link><guid>https://baozongwi.xyz/p/flask-pin-calculation/</guid><pubDate>Mon, 19 Aug 2024 09:09:00 +0000</pubDate><description>0x01 前言 最近有道flask不仅仅可以绕过黑名单而且开启了debug模式可以进行pin值计算getshell
0x02 原理 pin码是flask在开启debug模式下，进行代码调试模式所需的进入密码，需要正确的PIN码才能进入调试模式,可以理解为自带的webshell
计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 probably_public_bits = [ username 运行当前程序的用户名 modname 当前对象的模块名，默认为flask.app getattr(app, &amp;amp;#34;__name__&amp;amp;#34;, app.__class__.__name__) 当前对象的名称，默认为Flask getattr(mod, &amp;amp;#34;__file__&amp;amp;#34;, None) flask包内的app.py的绝对路径 ] private_bits = [ str(uuid.getnode()) Mac地址的整型，通过int(Mac, 16)可以获取 get_machine_id() [ docker /proc/self/cgroup，正则分割 Linux /etc/machine-id，/proc/sys/kernl/random/boot_id，前者固定后者不固定 macOS ioreg -c IOPlatformExpertDevice -d 2中&amp;amp;#34;serial-number&amp;amp;#34; = &amp;amp;lt;{ID}部分 Windows 注册表HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Cryptography/MachineGuid ] ] 那么我们主要研究如何得到docker的相关</description><content:encoded>0x01 前言 最近有道flask不仅仅可以绕过黑名单而且开启了debug模式可以进行pin值计算getshell
0x02 原理 pin码是flask在开启debug模式下，进行代码调试模式所需的进入密码，需要正确的PIN码才能进入调试模式,可以理解为自带的webshell
计算 1 2 3 4 …</content:encoded></item><item><title>url中的好玩的姿势</title><link>https://baozongwi.xyz/p/url-interesting-techniques/</link><guid>https://baozongwi.xyz/p/url-interesting-techniques/</guid><pubDate>Sat, 17 Aug 2024 08:49:37 +0000</pubDate><description>ssrf...</description><content:encoded>0x01 前言 太久没有ssrf了，有些许遗忘，来复习一下顺便发现了一点点新姿势
0x02 url引用知识 许多URL结构保留一些特殊的字符用来表示特殊的含义，这些符号在URL中不同的位置有着其特殊的语义。 字符”;”, “/”, “?”, “:”, “@”, “=” 和”&amp;amp;amp;amp;”是被保留的。 …</content:encoded></item><item><title>docker学习以及基础web题目部署</title><link>https://baozongwi.xyz/p/docker-learning-and-basic-web-deployment/</link><guid>https://baozongwi.xyz/p/docker-learning-and-basic-web-deployment/</guid><pubDate>Thu, 15 Aug 2024 21:23:03 +0000</pubDate><description>0x01 前言 docker必须要会啊，虽然折磨了我好久好久
这里使用的是抽奖得到的DK盾Ubuntu22
0x02 action 安装 1 2 3 4 5 6 7 8 sudo apt update sudo apt install apt-transport-https curl curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg echo &amp;amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release &amp;amp;amp;&amp;amp;amp; echo &amp;amp;#34;$VERSION_CODENAME&amp;amp;#34;) stable&amp;amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list &amp;amp;gt; /dev/null sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动＋拉取最简单的镜像 1 2 systemctl start docker systemctl status docker 配置 换源即可
1 2 3 4 5 6 7 8 9 10 11 12 sudo rm /etc/docker/daemon.json sudo vim /etc/docker/daemon.json { &amp;amp;#34;registry-mirrors&amp;amp;#34;: [ &amp;amp;#34;https://docker.1ms.run&amp;amp;#34; ] } sudo systemctl daemon-reload sudo systemctl restart docker 随便搞个镜像看看行不行，这里是一个php的RCE题目，代码在</description><content:encoded>0x01 前言 docker必须要会啊，虽然折磨了我好久好久
这里使用的是抽奖得到的DK盾Ubuntu22
0x02 action 安装 1 2 3 4 5 6 7 8 sudo apt update sudo apt install apt-transport-https curl curl …</content:encoded></item><item><title>一个echo能干嘛</title><link>https://baozongwi.xyz/p/what-can-echo-do/</link><guid>https://baozongwi.xyz/p/what-can-echo-do/</guid><pubDate>Thu, 15 Aug 2024 19:30:06 +0000</pubDate><description>0x01 前言 今天看了一下一道命令执行，只有echo，其他任何命令都没有的情况如果获得flag
说实话我测试了很久但是还是卡着了,什么环境变量啊七七八八的,但是这些方法本质都是构造出命令,可是如果bash中没有命令的情况如何解决呢
0x02 学习 基础 echo命令能干什么我们来了解一下
echo 命令主要用于在命令行界面（如 Linux、Unix 或 macOS 的终端，或 Windows 的命令提示符）中显示文本字符串。
那么自然也有与符号的衔接
项 描述 \a 显示警告 \b 显示退格 \c 在输出中禁止另外跟在最终参数后面的换行字符。 所有跟在 \c 序列后的字符都被忽略。 \f 显示走纸字符。 \n 显示换行字符。 \r 显示一个回车字符。 \t 显示制表符。 \v 显示垂直制表符。 \ 显示反斜杠符号。 \0数字 显示一个 ASCII 值为 0、1、2、3 位八进制数的八位字符。 大部分的我们都认识了，但是这个八进制打印字符我们可以做个例子
1 2 echo -e &amp;amp;#34;\0123&amp;amp;#34; 这里将会打印八进制为123的字符即S 1 2 echo -e &amp;amp;#34;\0173&amp;amp;#34; 这里会打印八进制为173，十进制为123的字符即{ 1 2 3 4 5 6 7 8 9 10 11 12 def decimal_to_octal(decimal_number): return oct(decimal_number)[2:] if __name__ == &amp;amp;#34;__main__&amp;amp;#34;: # 获取用户输入 decimal_number = int(input(&amp;amp;#34;请输入一个十进制整数: &amp;amp;#34;)) # 转换为八进制 octal_number = decimal_to_octal(decimal_number) # 输出结果 print(f&amp;amp;#34;{decimal_number} 的八进制表示为: {octal_number}&amp;amp;#34;) 这里还有个问题就是如何去解析</description><content:encoded>0x01 前言 今天看了一下一道命令执行，只有echo，其他任何命令都没有的情况如果获得flag
说实话我测试了很久但是还是卡着了,什么环境变量啊七七八八的,但是这些方法本质都是构造出命令,可是如果bash中没有命令的情况如何解决呢
0x02 学习 基础 echo命令能干什么我们来了解一下
echo …</content:encoded></item><item><title>Liu ✌最帅</title><link>https://baozongwi.xyz/p/liu-most-handsome/</link><guid>https://baozongwi.xyz/p/liu-most-handsome/</guid><pubDate>Wed, 14 Aug 2024 22:36:06 +0000</pubDate><description>用服务器托管博客</description><content:encoded>0x01 前言 我实在是受不了GitHub的访问太慢了,而且要魔法,也不是很方便,于是去腾子那里注册了一个xyz我是觉得很有意思的名字啦昂,但是中途出现了一些意外
0x02 自己倒腾 域名解析 我像网上一般,直接先在github仓库里面创建
1 CNAME:baozongwi.xyz 然后配置好之 …</content:encoded></item><item><title>create_function()注入</title><link>https://baozongwi.xyz/p/create-function-injection/</link><guid>https://baozongwi.xyz/p/create-function-injection/</guid><pubDate>Sat, 10 Aug 2024 18:45:05 +0000</pubDate><description>0x01 前言 对于这个函数,我之前一直是一知半解,基本就是知道一个闭合,然后嵌入恶意代码就啥都不知道了,昨天遇到了一个相关知识点,来彻底搞懂他
0x02 内容 了解 首先去官方手册看看这个函数
也就是说和eval有着异曲同工之妙
我们都知道eval()会使内置语句php解析,所以我们用;等闭合内部语句,然后代码执行,那么现在来看看这个
实验 首先最基本的用法创建匿名函数
1 create_function(&amp;amp;#39;$name&amp;amp;#39;,&amp;amp;#39;echo $name.&amp;amp;#34;wi&amp;amp;#34;&amp;amp;#39;) 等价
1 2 3 function fT($fname) { echo $fname.&amp;amp;#34;wi&amp;amp;#34;; } 那么这样一看就很明白了
随便写个代码
1 2 3 4 5 6 7 8 9 &amp;amp;lt;?php $id=$_GET[&amp;amp;#39;id&amp;amp;#39;]; $str2=&amp;amp;#39;echo $a&amp;amp;#39;.&amp;amp;#39;test&amp;amp;#39;.$id.&amp;amp;#34;;&amp;amp;#34;; echo $str2; echo &amp;amp;#34;&amp;amp;lt;br/&amp;amp;gt;&amp;amp;#34;; echo &amp;amp;#34;==============================&amp;amp;#34;; echo &amp;amp;#34;&amp;amp;lt;br/&amp;amp;gt;&amp;amp;#34;; $f1 = create_function(&amp;amp;#39;$a&amp;amp;#39;,$str2); ?&amp;amp;gt; 起一个环境
此时所创建的函数应该为
1 2 3 4 5 6 7 function fT($a) { echo $a.&amp;amp;#39;test&amp;amp;#39;.$id.; } 变为 function fT($a){ echo $a.&amp;amp;#39;test&amp;amp;#39;;}eval($_POST[&amp;amp;#39;a&amp;amp;#39;]);/*; } 那么后续代码都会被注释,且我们也成功注入
例题 一道很简单的题目(P神出的)
1 2 3 4 5 6 7 8 9 &amp;amp;lt;?php $action = $_GET[&amp;amp;#39;action&amp;amp;#39;] ?? &amp;amp;#39;&amp;amp;#39;; $arg = $_GET[&amp;amp;#39;arg&amp;amp;#39;] ?? &amp;amp;#39;&amp;amp;#39;; if(preg_match(&amp;amp;#39;/^[a-z0-9_]*$/isD&amp;amp;#39;, $action)) { show_source(__FILE__); } else { $action(&amp;amp;#39;&amp;amp;#39;, $arg); } 这里我们使用\来绕过</description><content:encoded>0x01 前言 对于这个函数,我之前一直是一知半解,基本就是知道一个闭合,然后嵌入恶意代码就啥都不知道了,昨天遇到了一个相关知识点,来彻底搞懂他
0x02 内容 了解 首先去官方手册看看这个函数
也就是说和eval有着异曲同工之妙
我们都知道eval()会使内置语句php解析,所以我们用;等闭合内部 …</content:encoded></item><item><title>hexo部署到GitHub的一场血案</title><link>https://baozongwi.xyz/p/hexo-github-deployment-troubleshooting/</link><guid>https://baozongwi.xyz/p/hexo-github-deployment-troubleshooting/</guid><pubDate>Thu, 08 Aug 2024 21:19:14 +0000</pubDate><description>0x01 前言 介于第一个友链的诞生，那我必须得第一时间部署blog到GitHub，但是确实并没有那么顺畅，于是找到了几种方法来解决这个问题
0x02 action ssl错误 这个可能是ssl证书或者是短暂的，但是不说那么多，直接上解决方案
首先第一种
将https地址换成ssh链接的
1 2 3 4 deploy: type: git repo: https://github.com/baozongwi/baozongwi.github.io.git/ branch: main 替换为
1 2 3 4 deploy: type: git repo: git@github.com:baozongwi/baozongwi.github.io.git branch: main 第二种，忽略ssl链接
1 git config --global http.sslVerify &amp;amp;#34;false&amp;amp;#34; GitHub超时 首先看看自己网络是否有问题
1 ping github.com 第一种设置proxy
取消proxy
1 2 3 git config --global --unset http.proxy git config --global --unset https.proxy 设置proxy</description><content:encoded>0x01 前言 介于第一个友链的诞生，那我必须得第一时间部署blog到GitHub，但是确实并没有那么顺畅，于是找到了几种方法来解决这个问题
0x02 action ssl错误 这个可能是ssl证书或者是短暂的，但是不说那么多，直接上解决方案
首先第一种
将https地址换成ssh链接的
1 2 3 …</content:encoded></item><item><title>浅谈hackbar</title><link>https://baozongwi.xyz/p/hackbar-brief-introduction/</link><guid>https://baozongwi.xyz/p/hackbar-brief-introduction/</guid><pubDate>Thu, 08 Aug 2024 11:53:28 +0000</pubDate><description>新手最喜欢的</description><content:encoded>0x01 前言 这个工具，想必大家是都知道的，但是鉴于hackbar有部分偷懒功能，而且之前学习nodejs污染的时候有师傅说，&amp;amp;amp;ldquo;hackbar的POST不能传json只可以传键值对&amp;amp;amp;rdquo;，所以我觉得还是有必要一说
0x02 安装 鉴于安装过程相当简单，那我就顺便讲讲吧
首先进 …</content:encoded></item></channel></rss>